<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Мастер слияния</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #F3F4F6;
            --bg-dark: #111827;
            --card-bg-light: #FFFFFF;
            --card-bg-dark: #1F2937;
            --text-light: #111827;
            --text-dark: #F9FAFB;
            --text-secondary-light: #4B5563;
            --text-secondary-dark: #9CA3AF;
            --accent-color: #3B82F6; /* Blue-500 */
            --accent-hover: #2563EB; /* Blue-600 */
            --grid-bg-light: #D1D5DB; /* Gray-300 */
            --grid-bg-dark: #374151; /* Gray-700 */
            --cell-bg-light: #E5E7EB; /* Gray-200 */
            --cell-bg-dark: #4B5563; /* Gray-600 */
        }
        
        .dark {
            --bg-main: var(--bg-dark);
            --card-bg: var(--card-bg-dark);
            --text-main: var(--text-dark);
            --text-secondary: var(--text-secondary-dark);
            --grid-bg: var(--grid-bg-dark);
            --cell-bg: var(--cell-bg-dark);
        }

        html:not(.dark) {
            --bg-main: var(--bg-light);
            --card-bg: var(--card-bg-light);
            --text-main: var(--text-light);
            --text-secondary: var(--text-secondary-light);
            --grid-bg: var(--grid-bg-light);
            --cell-bg: var(--cell-bg-light);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .game-wrapper {
            width: 100%;
            max-width: 420px;
            height: 100%;
            max-height: 840px;
            background-color: var(--card-bg);
            border-radius: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease, height 0.3s ease, padding-bottom 0.3s ease;
        }
        
        .screen {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .screen.hidden {
            display: none;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 50;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            width: 90%;
            max-width: 380px;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .btn {
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            transition: all 0.2s ease;
            transform: scale(1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
        }
        
        .btn-secondary {
            background-color: var(--cell-bg);
            color: var(--text-main);
        }
        .btn-secondary:hover {
            opacity: 0.9;
        }
        
        .icon-btn {
            background-color: var(--cell-bg);
            color: var(--text-secondary);
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            color: var(--text-main);
            background-color: var(--grid-bg);
        }

        #game-grid-container {
            position: relative;
        }

        #game-grid {
            position: relative;
            background-color: var(--grid-bg);
            padding: 0.75rem;
            border-radius: 1rem;
            touch-action: none;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0.75rem;
        }
        
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 800;
            font-size: clamp(1rem, 4.5vw, 1.75rem);
            border-radius: 0.5rem;
            color: white;
            transition: transform 0.2s ease-in-out, top 0.3s ease-in-out, left 0.3s ease-in-out;
            transform: scale(1);
            z-index: 5;
            will-change: transform, top, left;
        }
        
        .tile.selected {
            transform: scale(0.9);
            filter: brightness(1.2);
            border: 3px solid white;
        }
        
        .tile.merged {
            animation: merge-pop 0.3s ease-out forwards;
        }

        @keyframes merge-pop {
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .switch {
          position: relative; display: inline-block;
          width: 60px; height: 34px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
          position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
          background-color: var(--cell-bg); -webkit-transition: .4s; transition: .4s;
          border-radius: 34px;
        }
        .slider:before {
          position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px;
          background-color: white; -webkit-transition: .4s; transition: .4s;
          border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body>
    <audio id="bg-music" src="music.mp3" loop></audio>

    <div class="game-container">
        <div class="game-wrapper">

            <!-- Main Menu Screen -->
            <div id="main-menu" class="screen p-8 flex flex-col justify-between items-center text-center">
                <div></div> <!-- Spacer -->
                <div class="w-full">
                    <h1 class="text-6xl font-black tracking-tighter" style="background: linear-gradient(45deg, var(--accent-color), #f87171); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Мастер слияния</h1>
                    <p class="text-lg mt-2" style="color: var(--text-secondary)">Соединяй числа, ставь рекорды</p>
                    <div class="mt-12 flex flex-col items-center space-y-4">
                        <button id="play-btn" class="btn btn-primary w-full max-w-xs text-2xl py-4">Играть</button>
                        <button id="other-games-btn" class="btn btn-secondary w-full max-w-xs text-xl py-3">Другие игры</button>
                    </div>
                </div>
                <div class="flex space-x-4">
                    <button id="stats-btn-main" class="icon-btn" aria-label="Статистика">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg>
                    </button>
                    <button id="rules-btn-main" class="icon-btn" aria-label="Правила">
                         <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
                    </button>
                    <button id="settings-btn-main" class="icon-btn" aria-label="Настройки">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06-.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                    </button>
                </div>
            </div>

            <!-- Game Screen -->
            <div id="game-screen" class="screen p-4 flex-col hidden">
                <div class="flex justify-between items-center p-4">
                    <div class="w-1/3 text-center bg-[var(--cell-bg)] p-2 px-4 rounded-xl">
                        <div class="text-xs font-bold uppercase" style="color: var(--text-secondary)">Счет</div>
                        <div id="current-score" class="text-2xl font-bold">0</div>
                    </div>
                     <button id="pause-btn" class="icon-btn" aria-label="Пауза">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                    </button>
                    <div class="w-1/3 flex justify-center items-center">
                        <div id="next-tile-preview" class="w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors" style="background-color: var(--cell-bg);"></div>
                    </div>
                </div>
                <div id="game-grid-container" class="w-full flex-grow p-1 flex items-center justify-center">
                    <div id="game-grid" class="w-full" style="aspect-ratio: 5 / 6;"></div>
                    <canvas id="line-canvas" class="absolute pointer-events-none z-10"></canvas>
                </div>
            </div>
            
            <!-- Other Games Screen -->
            <div id="other-games-screen" class="screen hidden p-4 flex flex-col">
                 <h1 class="text-3xl font-bold text-center mb-4">Другие игры</h1>
                 <div id="other-games-container" class="grid grid-cols-3 gap-x-4 gap-y-5 flex-grow overflow-y-auto p-2"></div>
                 <button id="back-to-menu-btn" class="btn btn-secondary w-full text-lg mt-4">Назад</button>
            </div>

        </div>
    </div>

    <!-- Modals -->
    <div id="modal-container">
        <!-- Pause Modal -->
        <div id="pause-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Пауза</h2>
                <div class="space-y-4">
                    <button id="resume-btn" class="btn btn-primary w-full text-lg">Продолжить</button>
                    <button id="restart-btn-pause" class="btn btn-secondary w-full text-lg">Начать заново</button>
                    <button id="main-menu-btn-pause" class="btn btn-secondary w-full text-lg">Главное меню</button>
                </div>
            </div>
        </div>
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-2">Игра окончена!</h2>
                <p class="mb-4" style="color: var(--text-secondary)">Ваш счет: <span id="final-score" class="font-bold">0</span></p>
                <div class="space-y-4">
                    <button id="restart-btn-gameover" class="btn btn-primary w-full text-lg">Попробовать снова</button>
                    <button id="main-menu-btn-gameover" class="btn btn-secondary w-full text-lg">Главное меню</button>
                </div>
            </div>
        </div>
        <!-- Settings Modal -->
        <div id="settings-modal" class="modal-overlay">
            <div class="modal-content text-left space-y-4">
                <h2 class="text-3xl font-bold mb-2 text-center">Настройки</h2>
                <div class="flex justify-between items-center">
                    <span class="text-lg">Темная тема</span>
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-lg">Музыка</span>
                     <label class="switch">
                        <input type="checkbox" id="music-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-lg">Звуки</span>
                    <input type="range" id="sfx-volume" class="w-1/2" min="0" max="100" value="70">
                </div>
                <button id="close-settings-btn" class="btn btn-secondary w-full text-lg !mt-6">Закрыть</button>
            </div>
        </div>
        <!-- Rules Modal -->
        <div id="rules-modal" class="modal-overlay">
            <div class="modal-content text-left">
                <h2 class="text-3xl font-bold mb-6 text-center">Правила игры</h2>
                <div class="space-y-3">
                    <p>● Соединяйте <strong>3+</strong> одинаковых числа.</p>
                    <p>● Длинные цепочки дают плитки большего номинала.</p>
                    <p>● Результат слияния ограничен: плитка не может стать больше чем на <strong>6</strong> порядков (например, из 2 → 128).</p>
                </div>
                <button id="close-rules-btn" class="btn btn-secondary w-full text-lg mt-6">Понятно</button>
            </div>
        </div>
        <!-- Stats Modal -->
        <div id="stats-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Статистика</h2>
                 <div class="space-y-3 text-left">
                    <div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Лучший счет</span><strong id="stats-high-score">0</strong></div>
                    <div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Макс. плитка</span><strong id="stats-max-tile">0</strong></div>
                </div>
                <button id="close-stats-btn" class="btn btn-secondary w-full text-lg mt-6">Закрыть</button>
            </div>
        </div>
        <!-- Continue Game Modal -->
        <div id="continue-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Продолжить?</h2>
                <p class="mb-6" style="color: var(--text-secondary)">У вас есть незаконченная игра. Хотите продолжить?</p>
                <div class="space-y-4">
                    <button id="continue-game-btn" class="btn btn-primary w-full text-lg">Продолжить</button>
                    <button id="new-game-confirm-btn" class="btn btn-secondary w-full text-lg">Начать новую</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game Constants & Elements
            const ROWS = 6;
            const COLS = 5;
            const MAX_MERGE_POWER = 6; // Max merge is current * 2^6

            const screens = {
                mainMenu: document.getElementById('main-menu'),
                game: document.getElementById('game-screen'),
                otherGames: document.getElementById('other-games-screen')
            };
            const gameWrapper = document.querySelector('.game-wrapper');
            const gameGrid = document.getElementById('game-grid');
            const lineCanvas = document.getElementById('line-canvas');
            const ctx = lineCanvas.getContext('2d');
            const currentScoreEl = document.getElementById('current-score');
            const highScoreEl = document.getElementById('stats-high-score');
            const nextTilePreviewEl = document.getElementById('next-tile-preview');
            const bgMusic = document.getElementById('bg-music');
            
            // Modals & Buttons
            const playBtn = document.getElementById('play-btn');
            const otherGamesBtn = document.getElementById('other-games-btn');
            const continueGameBtn = document.getElementById('continue-game-btn');
            const newGameConfirmBtn = document.getElementById('new-game-confirm-btn');
            const allButtons = document.querySelectorAll('button');
            const themeToggle = document.getElementById('theme-toggle');
            const musicToggle = document.getElementById('music-toggle');
            const sfxVolumeSlider = document.getElementById('sfx-volume');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const restartBtnPause = document.getElementById('restart-btn-pause');
            const mainMenuBtnPause = document.getElementById('main-menu-btn-pause');
            const restartBtnGameOver = document.getElementById('restart-btn-gameover');
            const mainMenuBtnGameOver = document.getElementById('main-menu-btn-gameover');
            
            // Game State
            let grid = [];
            let currentScore = 0;
            let isPaused = false;
            let isGameOver = false;
            let isMoving = false;
            let isSelecting = false;
            let selectedPath = [];
            let currentSelectionValue = 0;
            let vkUserId = null;
            let wasMusicPlaying = false;
            
            // Audio state
            let audioContextStarted = false;
            let mergeSynth, clickSynth;
            
            // App Data
            let appData = {
                theme: 'light',
                musicEnabled: true,
                sfxVolume: 70,
                stats: { highScore: 0, maxTile: 0 },
                savedGame: null
            };

            const TILE_COLORS = {
                2: 'bg-blue-400', 4: 'bg-blue-500', 8: 'bg-indigo-500', 16: 'bg-purple-500',
                32: 'bg-pink-500', 64: 'bg-red-500', 128: 'bg-orange-500', 256: 'bg-yellow-500',
                512: 'bg-lime-500', 1024: 'bg-green-500', 2048: 'bg-teal-500', 4096: 'bg-cyan-500',
                8192: 'bg-sky-500'
            };

            // --- Game Initialization ---
            
            async function init() {
                vkBridge.send('VKWebAppInit');
                
                vkBridge.subscribe(e => {
                    if (e.detail.type === 'VKWebAppViewHide') {
                        if (!bgMusic.paused) {
                            wasMusicPlaying = true;
                            bgMusic.pause();
                        }
                    }
                    if (e.detail.type === 'VKWebAppViewRestore') {
                        if (wasMusicPlaying && appData.musicEnabled) {
                           bgMusic.play().catch(e => {});
                        }
                        wasMusicPlaying = false;
                    }
                    if (e.detail.type === 'VKWebAppUpdateConfig') {
                        updateGameHeight(e.detail.data.safe_area_insets);
                    }
                });

                try {
                    const user = await vkBridge.send('VKWebAppGetUserInfo');
                    vkUserId = user.id;
                } catch (error) {
                    console.warn("Could not get VK User ID.", error);
                    vkUserId = 'test_user';
                }

                await loadData();
                setupAudio();
                applySettings();
                updateScore(0);
                addEventListeners();
                
                if (appData.savedGame && appData.savedGame.grid) {
                    document.getElementById('continue-modal').classList.add('active');
                } else {
                    showScreen('mainMenu');
                }
            }
            
            function setupAudio() {
                 mergeSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'fmsine', modulationIndex: 2, harmonicity: 0.5 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
                }).toDestination();
                clickSynth = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
                }).toDestination();
            }
            
            async function initAudio() {
                if (audioContextStarted) return;
                try {
                    await Tone.start();
                    audioContextStarted = true;
                    console.log('Audio context started.');
                    if (appData.musicEnabled) {
                        bgMusic.play().catch(e => console.log("Music play failed:", e));
                    }
                } catch(e) {
                    console.error("Could not start audio context:", e);
                }
            }

            function startGame() {
                appData.savedGame = null;
                saveData();

                showScreen('game');
                grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                updateScore(0);
                isGameOver = false;

                const initialValues = [2, 4, 8];
                const fillGrid = () => {
                    for(let r = 0; r < ROWS; r++) {
                        for(let c = 0; c < COLS; c++) {
                            grid[r][c] = initialValues[Math.floor(Math.random() * initialValues.length)];
                        }
                    }
                };
                
                fillGrid();
                while (!isAnyMovePossible()) {
                    fillGrid();
                }
                
                renderGrid(true);
                setTimeout(resizeCanvas, 100);
            }

            function resumeSavedGame() {
                if (!appData.savedGame || !appData.savedGame.grid) return;
                showScreen('game');
                grid = appData.savedGame.grid;
                updateScore(appData.savedGame.score, false);
                isGameOver = false;
                renderGrid(true);
                appData.savedGame = null;
                saveData();
                setTimeout(resizeCanvas, 100);
            }

            function showScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.add('hidden'));
                screens[screenName].classList.remove('hidden');
                
                vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' })
                  .then(() => {
                      vkBridge.send('VKWebAppGetClientConfig').then(config => {
                          if (config.safe_area_insets) {
                               updateGameHeight(config.safe_area_insets);
                          }
                      });
                  })
                  .catch(e => {});
            }

            function updateGameHeight(safeArea) {
                if (safeArea && safeArea.bottom > 0) {
                    gameWrapper.style.height = `calc(100% - ${safeArea.bottom}px)`;
                } else {
                    gameWrapper.style.height = '100%';
                }
                setTimeout(resizeCanvas, 350); // wait for css transition
            }

            // --- UI & Rendering ---
            
            function renderGrid(isInitial = false) {
                gameGrid.innerHTML = '';
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        createTile(i, j, grid[i][j], isInitial);
                    }
                }
            }

            function createTile(r, c, value, isInitial = false, isNew = false) {
                if (value === 0) return;
                const tile = document.createElement('div');
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                tile.id = `tile-${r}-${c}`;
                tile.className = `tile ${TILE_COLORS[value] || 'bg-gray-800'}`;
                tile.textContent = value;
                tile.style.width = `${cellWidth}px`;
                tile.style.height = `${cellHeight}px`;
                tile.style.left = `${c * (cellWidth + gap)}px`;
                
                if (isNew) {
                    tile.style.top = `-${cellHeight}px`;
                } else {
                    tile.style.top = `${r * (cellHeight + gap)}px`;
                }

                if (isInitial) {
                    tile.style.transform = 'scale(0)';
                }
                
                gameGrid.appendChild(tile);

                requestAnimationFrame(() => {
                    tile.style.transition = 'transform 0.2s, top 0.3s, left 0.3s';
                    if (isInitial) {
                        tile.style.transform = 'scale(1)';
                    }
                     if (isNew) {
                        tile.style.top = `${r * (cellHeight + gap)}px`;
                     }
                });
            }

            function updateScore(newScore, isAdding = false) {
                if (isAdding) currentScore += newScore;
                else currentScore = newScore;
                currentScoreEl.textContent = currentScore;
                if (currentScore > appData.stats.highScore) {
                    appData.stats.highScore = currentScore;
                    updateStatsUI();
                }
            }
            
            function resizeCanvas() {
                const gridRect = gameGrid.getBoundingClientRect();
                const containerRect = gameGrid.parentElement.getBoundingClientRect();
                if(gridRect.width === 0) return;
                lineCanvas.width = gridRect.width;
                lineCanvas.height = gridRect.height;
                lineCanvas.style.top = `${gridRect.top - containerRect.top}px`;
                lineCanvas.style.left = `${gridRect.left - containerRect.left}px`;
            }

            // --- Game Logic ---

            function getGridMetrics() {
                const gap = parseFloat(getComputedStyle(gameGrid).gap);
                const cellWidth = (gameGrid.clientWidth - (gap * (COLS - 1))) / COLS;
                const cellHeight = (gameGrid.clientHeight - (gap * (ROWS - 1))) / ROWS;
                return { cellWidth, cellHeight, gap };
            }

            function getCellFromEvent(e) {
                const rect = gameGrid.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return null;
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const c = Math.floor(x / (cellWidth + gap));
                const r = Math.floor(y / (cellHeight + gap));
                return (r >= 0 && r < ROWS && c >= 0 && c < COLS) ? {r, c} : null;
            }
            
            async function applyGravityAndRefillAnimated() {
                isMoving = true;
                const fallDuration = 300;
                const { cellHeight, gap } = getGridMetrics();
                for (let c = 0; c < COLS; c++) {
                    let writeRow = ROWS - 1;
                    for (let r = ROWS - 1; r >= 0; r--) {
                        if (grid[r][c] !== 0) {
                            if (writeRow !== r) {
                                grid[writeRow][c] = grid[r][c];
                                grid[r][c] = 0;
                                const tileEl = document.getElementById(`tile-${r}-${c}`);
                                if (tileEl) {
                                    tileEl.style.top = `${writeRow * (cellHeight + gap)}px`;
                                    tileEl.id = `tile-${writeRow}-${c}`;
                                }
                            }
                            writeRow--;
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                const initialValues = [2, 4, 8];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === 0) {
                            const value = initialValues[Math.floor(Math.random() * initialValues.length)];
                            grid[r][c] = value;
                            createTile(r, c, value, false, true);
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                isMoving = false;
            }
            
            function isAnyMovePossible() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (isMovePossibleFrom(r, c)) return true;
                    }
                }
                return false;
            }

            function isMovePossibleFrom(r, c) {
                const value = grid[r][c];
                const q = [{r,c}];
                const visited = new Set([`${r},${c}`]);
                let count = 0;
                while(q.length > 0) {
                    const curr = q.shift();
                    count++;
                    if(count >= 3) return true;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = curr.r + dr;
                            const nc = curr.c + dc;
                            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && grid[nr][nc] === value && !visited.has(`${nr},${nc}`)) {
                                visited.add(`${nr},${nc}`);
                                q.push({r: nr, c: nc});
                            }
                        }
                    }
                }
                return false;
            }

            function handleGameOver() {
                isGameOver = true;
                appData.savedGame = null; // Clear saved game on game over
                saveData();
                vkBridge.send('VKWebAppShowInterstitialAd').catch(e => {});
                setTimeout(() => {
                    document.getElementById('final-score').textContent = currentScore;
                    document.getElementById('game-over-modal').classList.add('active');
                }, 500);
            }

            // --- Event Handlers & Controls ---

            function addEventListeners() {
                playBtn.addEventListener('click', () => { initAudio(); playClickSound(); startGame(); });
                allButtons.forEach(btn => btn.addEventListener('click', playClickSound));
                
                document.getElementById('stats-btn-main').addEventListener('click', () => { updateStatsUI(); document.getElementById('stats-modal').classList.add('active'); });
                document.getElementById('rules-btn-main').addEventListener('click', () => document.getElementById('rules-modal').classList.add('active'));
                document.getElementById('settings-btn-main').addEventListener('click', () => document.getElementById('settings-modal').classList.add('active'));
                otherGamesBtn.addEventListener('click', () => { initAudio(); showScreen('otherGames'); });
                document.getElementById('back-to-menu-btn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('other-games-container').addEventListener('click', e => {
                    const gameEl = e.target.closest('[data-app-id]');
                    if (gameEl) vkBridge.send('VKWebAppOpenApp', { app_id: parseInt(gameEl.dataset.appId) });
                });
                resumeBtn.addEventListener('click', () => { isPaused = false; document.getElementById('pause-modal').classList.remove('active'); });
                [restartBtnPause, restartBtnGameOver].forEach(btn => btn.addEventListener('click', () => {
                    document.getElementById('pause-modal').classList.remove('active');
                    document.getElementById('game-over-modal').classList.remove('active');
                    isPaused = false;
                    startGame();
                }));
                [mainMenuBtnPause, mainMenuBtnGameOver].forEach(btn => btn.addEventListener('click', () => {
                    document.getElementById('pause-modal').classList.remove('active');
                    document.getElementById('game-over-modal').classList.remove('active');
                    isPaused = false;
                    appData.savedGame = null;
                    saveData();
                    showScreen('mainMenu');
                }));
                continueGameBtn.addEventListener('click', () => { initAudio(); document.getElementById('continue-modal').classList.remove('active'); resumeSavedGame(); });
                newGameConfirmBtn.addEventListener('click', () => {
                    document.getElementById('continue-modal').classList.remove('active');
                    appData.savedGame = null;
                    saveData();
                    showScreen('mainMenu');
                });
                document.getElementById('close-settings-btn').addEventListener('click', () => document.getElementById('settings-modal').classList.remove('active'));
                document.getElementById('close-rules-btn').addEventListener('click', () => document.getElementById('rules-modal').classList.remove('active'));
                document.getElementById('close-stats-btn').addEventListener('click', () => document.getElementById('stats-modal').classList.remove('active'));
                pauseBtn.addEventListener('click', () => { if (!isMoving) { isPaused = true; document.getElementById('pause-modal').classList.add('active'); }});
                themeToggle.addEventListener('change', () => {
                    appData.theme = themeToggle.checked ? 'dark' : 'light';
                    applySettings();
                    saveData();
                });
                musicToggle.addEventListener('change', () => {
                    appData.musicEnabled = musicToggle.checked;
                    applySettings();
                    saveData();
                });
                sfxVolumeSlider.addEventListener('input', (e) => {
                    appData.sfxVolume = e.target.value;
                    applySettings();
                    saveData();
                });
                const gridContainer = document.getElementById('game-grid-container');
                gridContainer.addEventListener('mousedown', handleSelectionStart);
                gridContainer.addEventListener('mousemove', handleSelectionMove);
                document.addEventListener('mouseup', handleSelectionEnd);
                document.addEventListener('mouseleave', handleSelectionEnd);
                gridContainer.addEventListener('touchstart', handleSelectionStart, { passive: false });
                gridContainer.addEventListener('touchmove', handleSelectionMove, { passive: false });
                document.addEventListener('touchend', handleSelectionEnd);
                window.addEventListener('resize', resizeCanvas);
            }

            function handleSelectionStart(e) {
                if (isMoving || isGameOver || isPaused) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (cell && grid[cell.r][cell.c] > 0) {
                    isSelecting = true;
                    currentSelectionValue = grid[cell.r][cell.c];
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                    updateNextTilePreview();
                }
            }
            
            function handleSelectionMove(e) {
                if (!isSelecting || selectedPath.length === 0) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (!cell) return;
                const lastCell = selectedPath[selectedPath.length - 1];
                if (cell.r === lastCell.r && cell.c === lastCell.c) return;

                if (selectedPath.length > 1) {
                    const secondLast = selectedPath[selectedPath.length - 2];
                    if (cell.r === secondLast.r && cell.c === secondLast.c) {
                        const removed = selectedPath.pop();
                        document.getElementById(`tile-${removed.r}-${removed.c}`).classList.remove('selected');
                        drawLinePath();
                        updateNextTilePreview();
                        return;
                    }
                }

                const alreadySelected = selectedPath.some(p => p.r === cell.r && p.c === cell.c);
                const isAdjacent = Math.abs(cell.r - lastCell.r) <= 1 && Math.abs(cell.c - lastCell.c) <= 1;

                if (!alreadySelected && isAdjacent && grid[cell.r][cell.c] === currentSelectionValue) {
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                    updateNextTilePreview();
                }
            }

            async function handleSelectionEnd() {
                if (!isSelecting) return;
                isSelecting = false;
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                if (selectedPath.length >= 3) {
                    isMoving = true;
                    const power = Math.min(MAX_MERGE_POWER, Math.floor((selectedPath.length - 1) / 2));
                    const newValue = currentSelectionValue * Math.pow(2, power);
                    playMergeSound(newValue);
                    const mergeTargetCell = selectedPath[selectedPath.length - 1];
                    const mergeTargetEl = document.getElementById(`tile-${mergeTargetCell.r}-${mergeTargetCell.c}`);
                    let mergeScore = 0;
                    const animations = [];
                    const mergeTargetPos = { left: mergeTargetEl.style.left, top: mergeTargetEl.style.top };

                    for (const cell of selectedPath) {
                        mergeScore += grid[cell.r][cell.c];
                        const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                        if (tileEl && tileEl !== mergeTargetEl) {
                            grid[cell.r][cell.c] = 0;
                            tileEl.style.transition = 'top 0.15s ease-out, left 0.15s ease-out, transform 0.15s ease-out';
                            tileEl.style.left = mergeTargetPos.left;
                            tileEl.style.top = mergeTargetPos.top;
                            tileEl.style.transform = 'scale(0.5)';
                            tileEl.style.zIndex = '1';
                            animations.push(new Promise(resolve => setTimeout(() => {
                                tileEl.remove(); resolve();
                            }, 150)));
                        }
                    }
                    await Promise.all(animations);
                    grid[mergeTargetCell.r][mergeTargetCell.c] = newValue;
                    if(mergeTargetEl) {
                        mergeTargetEl.className = `tile merged ${TILE_COLORS[newValue] || 'bg-gray-800'}`;
                        mergeTargetEl.textContent = newValue;
                        mergeTargetEl.classList.remove('selected');
                    }
                    updateScore(mergeScore, true);
                    if (newValue > appData.stats.maxTile) {
                        appData.stats.maxTile = newValue;
                        updateStatsUI();
                    }
                    
                    appData.savedGame = { grid: grid, score: currentScore };
                    await saveData();

                    await new Promise(resolve => setTimeout(resolve, 300));
                    if(mergeTargetEl) mergeTargetEl.classList.remove('merged');
                    await applyGravityAndRefillAnimated();
                    if (!isAnyMovePossible()) handleGameOver();
                } else {
                     clearSelectionUI();
                }
                selectedPath = [];
                currentSelectionValue = 0;
                updateNextTilePreview();
            }

            function clearSelectionUI() { document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected')); }
            
            function getTileCenter(r, c) {
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const x = c * (cellWidth + gap) + cellWidth / 2;
                const y = r * (cellHeight + gap) + cellHeight / 2;
                return { x, y };
            }

            function drawLinePath() {
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                if (selectedPath.length < 2) return;
                ctx.beginPath();
                const startPoint = getTileCenter(selectedPath[0].r, selectedPath[0].c);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < selectedPath.length; i++) {
                    const point = getTileCenter(selectedPath[i].r, selectedPath[i].c);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }

            function updateNextTilePreview() {
                if (selectedPath.length < 3) {
                    nextTilePreviewEl.textContent = '';
                    nextTilePreviewEl.className = 'w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors';
                    nextTilePreviewEl.style.backgroundColor = 'var(--cell-bg)';
                    return;
                }
                const power = Math.min(MAX_MERGE_POWER, Math.floor((selectedPath.length - 1) / 2));
                const newValue = currentSelectionValue * Math.pow(2, power);
                
                nextTilePreviewEl.textContent = newValue;
                const colorClass = TILE_COLORS[newValue] || 'bg-gray-800';
                nextTilePreviewEl.className = `w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors ${colorClass}`;
                nextTilePreviewEl.style.backgroundColor = '';
            }

            // --- Sounds ---
            function playMergeSound(value) {
                if(!audioContextStarted) return;
                const baseNote = 110;
                const note = baseNote * Math.pow(2, (Math.log2(value / 2) + 4) / 12);
                mergeSynth.triggerAttackRelease(note, '8n', Tone.now());
                mergeSynth.triggerAttackRelease(note * 1.5, '8n', Tone.now() + 0.05);
            }

            function playClickSound() {
                if(!audioContextStarted) return;
                clickSynth.triggerAttackRelease('C5', '16n');
            }

            // --- Settings & Persistence ---
            function applySettings() {
                document.documentElement.classList.toggle('dark', appData.theme === 'dark');
                themeToggle.checked = appData.theme === 'dark';
                
                musicToggle.checked = appData.musicEnabled;
                 if (appData.musicEnabled && audioContextStarted) {
                    bgMusic.play().catch(e => {});
                } else {
                    bgMusic.pause();
                }
                bgMusic.volume = 0.3;

                sfxVolumeSlider.value = appData.sfxVolume;
                const gain = appData.sfxVolume > 0 ? Tone.gainToDb((appData.sfxVolume / 100) * 0.7) : -Infinity;
                Tone.Destination.volume.value = gain;
            }

            async function saveData() {
                if (!vkUserId) return;
                const storageKey = `mergemaster_data_${vkUserId}`;
                try {
                    await vkBridge.send('VKWebAppStorageSet', { key: storageKey, value: JSON.stringify(appData) });
                } catch (error) {
                    localStorage.setItem(storageKey, JSON.stringify(appData));
                }
            }

            async function loadData() {
                if (!vkUserId) return;
                const storageKey = `mergemaster_data_${vkUserId}`;
                let loadedData = null;
                try {
                    const response = await vkBridge.send('VKWebAppStorageGet', { keys: [storageKey] });
                    if (response.keys[0]?.value) loadedData = JSON.parse(response.keys[0].value);
                } catch (error) {
                    const localData = localStorage.getItem(storageKey);
                    if (localData) loadedData = JSON.parse(localData);
                }
                if (loadedData) {
                    appData = { ...appData, ...loadedData };
                    appData.stats = { ...{ highScore: 0, maxTile: 0 }, ...loadedData.stats };
                }
                updateStatsUI();
            }
            
            function updateStatsUI() {
                highScoreEl.textContent = appData.stats.highScore;
                document.getElementById('stats-max-tile').textContent = appData.stats.maxTile;
            }

            // --- Start the engine ---
            init();
        });
    </script>
</body>
</html>

