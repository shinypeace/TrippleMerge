<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Мастер слияния</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #F3F4F6;
            --bg-dark: #111827;
            --card-bg-light: #FFFFFF;
            --card-bg-dark: #1F2937;
            --text-light: #111827;
            --text-dark: #F9FAFB;
            --text-secondary-light: #4B5563;
            --text-secondary-dark: #9CA3AF;
            --accent-color: #3B82F6; 
            --accent-hover: #2563EB;
            --continue-color: #10B981; /* Emerald-500 */
            --continue-hover: #059669; /* Emerald-600 */
            --grid-bg-light: #D1D5DB;
            --grid-bg-dark: #374151;
            --cell-bg-light: #E5E7EB;
            --cell-bg-dark: #4B5563;
        }
        
        .dark {
            --bg-main: var(--bg-dark);
            --card-bg: var(--card-bg-dark);
            --text-main: var(--text-dark);
            --text-secondary: var(--text-secondary-dark);
            --grid-bg: var(--grid-bg-dark);
            --cell-bg: var(--cell-bg-dark);
        }

        html:not(.dark) {
            --bg-main: var(--bg-light);
            --card-bg: var(--card-bg-light);
            --text-main: var(--text-light);
            --text-secondary: var(--text-secondary-light);
            --grid-bg: var(--grid-bg-light);
            --cell-bg: var(--cell-bg-light);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .game-wrapper {
            width: 100%;
            max-width: 420px;
            height: 100%;
            max-height: 840px;
            background-color: var(--card-bg);
            border-radius: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease, height 0.3s ease, padding-bottom 0.3s ease;
        }
        
        .screen {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .screen.hidden {
            display: none;
        }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 50;
        }

        .modal-overlay.active { opacity: 1; visibility: visible; }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem; border-radius: 1.5rem;
            width: 90%; max-width: 380px; text-align: center;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content { transform: scale(1); }

        .btn {
            border-radius: 0.75rem; padding: 0.75rem 1.5rem;
            font-weight: 600; transition: all 0.2s ease;
            transform: scale(1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .btn:active { transform: scale(0.95); box-shadow: none; }
        .btn-primary { background-color: var(--accent-color); color: white; }
        .btn-primary:hover { background-color: var(--accent-hover); }
        .btn-secondary { background-color: var(--cell-bg); color: var(--text-main); }
        .btn-secondary:hover { opacity: 0.9; }
        .btn-continue { background-color: var(--continue-color); color: white; }
        .btn-continue:hover { background-color: var(--continue-hover); }
        
        .icon-btn {
            background-color: var(--cell-bg); color: var(--text-secondary);
            width: 3.5rem; height: 3.5rem; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s ease;
        }
        .icon-btn:hover { color: var(--text-main); background-color: var(--grid-bg); }

        #game-grid {
            position: relative; background-color: var(--grid-bg);
            padding: 0.5rem; border-radius: 1rem;
            touch-action: none; display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0.5rem;
        }
        
        .tile {
            position: absolute; display: flex;
            justify-content: center; align-items: center;
            font-weight: 900; font-size: clamp(1rem, 5vw, 1.8rem);
            border-radius: 0.375rem; color: white;
            transition: transform 0.2s ease, top 0.3s ease, left 0.3s ease, background-color 0.3s ease;
            transform: scale(1); z-index: 5;
            will-change: transform, top, left;
        }
        
        .tile.selected { transform: scale(0.9); filter: brightness(1.2); border: 3px solid white; }
        .tile.booster-selected { transform: scale(1.1); box-shadow: 0 0 20px 5px var(--accent-color); z-index: 10; }
        
        .tile.merged { animation: merge-pop 0.3s ease-out forwards; }
        @keyframes merge-pop { 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        
        .tile-upgrade { animation: upgrade-pop 0.4s ease-out forwards; }
        @keyframes upgrade-pop { 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--cell-bg); transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        .booster-btn {
            position: relative; background-color: var(--cell-bg);
            color: var(--text-main); border-radius: 0.75rem;
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 0.5rem;
            transition: all 0.2s ease;
        }
        .booster-btn.active { background-color: var(--accent-color); color: white; }
        .booster-count {
            position: absolute; top: -5px; right: -5px;
            background-color: var(--accent-color); color: white;
            font-size: 0.75rem; font-weight: bold;
            width: 1.5rem; height: 1.5rem;
            border-radius: 50%; display: flex;
            justify-content: center; align-items: center;
            border: 2px solid var(--card-bg);
        }
        .booster-btn.ad .booster-count { font-size: 0.6rem; }
    </style>
</head>
<body>
    <audio id="bg-music" src="music.mp3" loop></audio>

    <div class="game-container">
        <div class="game-wrapper">

            <!-- Main Menu Screen -->
            <div id="main-menu" class="screen p-8 flex flex-col justify-between items-center text-center">
                <div></div> <!-- Spacer -->
                <div class="w-full">
                    <h1 class="text-6xl font-black tracking-tighter" style="background: linear-gradient(45deg, var(--accent-color), #f87171); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Мастер слияния</h1>
                    <p class="text-lg mt-2" style="color: var(--text-secondary)">Соединяй числа, ставь рекорды</p>
                    <div id="menu-buttons-container" class="mt-12 flex flex-col items-center space-y-4">
                        <!-- Buttons are generated by JS -->
                    </div>
                </div>
                <div class="flex space-x-4">
                    <button id="stats-btn-main" class="icon-btn" aria-label="Статистика"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg></button>
                    <button id="rules-btn-main" class="icon-btn" aria-label="Правила"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg></button>
                    <button id="settings-btn-main" class="icon-btn" aria-label="Настройки"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button>
                </div>
            </div>

            <!-- Game Screen -->
            <div id="game-screen" class="screen p-4 flex-col hidden">
                <div class="flex justify-between items-center p-4">
                    <div class="w-1/3 text-center bg-[var(--cell-bg)] p-2 px-4 rounded-xl">
                        <div class="text-xs font-bold uppercase" style="color: var(--text-secondary)">Счет</div>
                        <div id="current-score" class="text-2xl font-bold">0</div>
                    </div>
                    <button id="pause-btn" class="icon-btn" aria-label="Пауза"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button>
                    <div class="w-1/3 flex justify-center items-center">
                        <div id="next-tile-preview" class="w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors" style="background-color: var(--cell-bg);"></div>
                    </div>
                </div>
                <div id="game-grid-container" class="w-full flex-grow p-1 flex items-center justify-center">
                    <div id="game-grid" class="w-full" style="aspect-ratio: 5 / 6;"></div>
                    <canvas id="line-canvas" class="absolute pointer-events-none z-10"></canvas>
                </div>
                <div id="booster-bar" class="flex justify-center items-center space-x-4 p-4">
                    <button id="booster-swap" class="booster-btn w-20 h-20">
                        <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>
                        <span class="mt-1 text-xs">Замена</span>
                        <div class="booster-count">3</div>
                    </button>
                    <button id="booster-erase" class="booster-btn w-20 h-20">
                        <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>
                        <span class="mt-1 text-xs">Убрать</span>
                        <div class="booster-count">3</div>
                    </button>
                </div>
            </div>
            
            <!-- Other Games Screen -->
            <div id="other-games-screen" class="screen hidden p-4 flex flex-col">
                 <h1 class="text-3xl font-bold text-center mb-4">Другие игры</h1>
                 <div id="other-games-container" class="grid grid-cols-3 gap-x-4 gap-y-5 flex-grow overflow-y-auto p-2"></div>
                 <button id="back-to-menu-btn" class="btn btn-secondary w-full text-lg mt-4">Назад</button>
            </div>

        </div>
    </div>

    <!-- Modals -->
    <div id="modal-container">
        <!-- New Game Confirm Modal -->
        <div id="new-game-confirm-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-2">Новая игра</h2>
                <p class="mb-6" style="color: var(--text-secondary)">Текущий прогресс будет потерян. Вы уверены?</p>
                <div class="space-y-4">
                    <button id="confirm-new-game-btn" class="btn btn-primary w-full text-lg">Да, начать новую</button>
                    <button id="cancel-new-game-btn" class="btn btn-secondary w-full text-lg">Отмена</button>
                </div>
            </div>
        </div>
        <!-- Mode Select Modal -->
        <div id="mode-select-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Выберите режим</h2>
                <div class="space-y-4">
                    <button class="btn btn-primary w-full text-lg" data-mode="classic">Классика</button>
                    <button class="btn btn-primary w-full text-lg" data-mode="hard">Хард</button>
                    <button id="cancel-mode-select-btn" class="btn btn-secondary w-full text-lg mt-4">Назад</button>
                </div>
            </div>
        </div>
        <!-- Other modals... -->
        <div id="pause-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-6">Пауза</h2><div class="space-y-4"><button id="resume-btn" class="btn btn-primary w-full text-lg">Продолжить</button><button id="restart-btn-pause" class="btn btn-secondary w-full text-lg">Начать заново</button><button id="main-menu-btn-pause" class="btn btn-secondary w-full text-lg">Главное меню</button></div></div></div>
        <div id="game-over-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-2">Игра окончена!</h2><p class="mb-4" style="color: var(--text-secondary)">Ваш счет: <span id="final-score" class="font-bold">0</span></p><div class="space-y-4"><button id="restart-btn-gameover" class="btn btn-primary w-full text-lg">Попробовать снова</button><button id="main-menu-btn-gameover" class="btn btn-secondary w-full text-lg">Главное меню</button></div></div></div>
        <div id="settings-modal" class="modal-overlay"><div class="modal-content text-left space-y-4"><h2 class="text-3xl font-bold mb-2 text-center">Настройки</h2><div class="flex justify-between items-center"><span class="text-lg">Темная тема</span><label class="switch"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label></div><div class="flex justify-between items-center"><span class="text-lg">Музыка</span><label class="switch"><input type="checkbox" id="music-toggle"><span class="slider"></span></label></div><div class="flex justify-between items-center"><span class="text-lg">Звуки</span><input type="range" id="sfx-volume" class="w-1/2" min="0" max="100" value="70"></div><button id="close-settings-btn" class="btn btn-secondary w-full text-lg !mt-6">Закрыть</button></div></div>
        <div id="rules-modal" class="modal-overlay"><div class="modal-content text-left"><h2 class="text-3xl font-bold mb-6 text-center">Правила игры</h2><div class="space-y-3"><p>● <strong>Классика:</strong> Соединяйте числа. При достижении определенных плиток (256, 2К и т.д.), самые маленькие числа на поле улучшаются!</p><p>● <strong>Хард:</strong> Режим без улучшений. Только вы и числа.</p><p>● Результат слияния ограничен: плитка не может стать больше чем на <strong>6</strong> порядков (например, из 2 → 128).</p></div><button id="close-rules-btn" class="btn btn-secondary w-full text-lg mt-6">Понятно</button></div></div>
        <div id="stats-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-6">Статистика</h2><div class="space-y-3 text-left"><div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Лучший счет</span><strong id="stats-high-score">0</strong></div><div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Макс. плитка</span><strong id="stats-max-tile">0</strong></div></div><button id="close-stats-btn" class="btn btn-secondary w-full text-lg mt-6">Закрыть</button></div></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ROWS = 6, COLS = 5, MAX_MERGE_POWER = 6;
            const screens = {
                mainMenu: document.getElementById('main-menu'),
                game: document.getElementById('game-screen'),
                otherGames: document.getElementById('other-games-screen')
            };
            const gameWrapper = document.querySelector('.game-wrapper'),
                  gameGrid = document.getElementById('game-grid'),
                  lineCanvas = document.getElementById('line-canvas'),
                  ctx = lineCanvas.getContext('2d'),
                  currentScoreEl = document.getElementById('current-score'),
                  highScoreEl = document.getElementById('stats-high-score'),
                  nextTilePreviewEl = document.getElementById('next-tile-preview'),
                  bgMusic = document.getElementById('bg-music'),
                  menuButtonsContainer = document.getElementById('menu-buttons-container');

            // Modals
            const newGameConfirmModal = document.getElementById('new-game-confirm-modal'),
                  modeSelectModal = document.getElementById('mode-select-modal');
            
            // Boosters
            const boosterSwapBtn = document.getElementById('booster-swap'),
                  boosterEraseBtn = document.getElementById('booster-erase');

            let grid = [], currentScore = 0, isPaused = false, isGameOver = false,
                isMoving = false, isSelecting = false, selectedPath = [],
                currentSelectionValue = 0, vkUserId = null, wasMusicPlaying = false,
                audioContextStarted = false, mergeSynth, clickSynth,
                boosterState = { mode: null, firstTile: null };

            let appData = {
                theme: 'dark', musicEnabled: true, sfxVolume: 70,
                stats: { highScore: 0, maxTile: 0 }, savedGame: null
            };

            const TILE_COLORS = { // Pastel Palette
                2: 'bg-[#a7f3d0]', 4: 'bg-[#fde68a]', 8: 'bg-[#fca5a5]', 16: 'bg-[#c4b5fd]',
                32: 'bg-[#a5f3fc]', 64: 'bg-[#d1d5db]', 128: 'bg-[#f9a8d4]', 256: 'bg-[#6ee7b7]',
                512: 'bg-[#fcd34d]', 1024: 'bg-[#f87171]', 2048: 'bg-[#a78bfa]', 4096: 'bg-[#67e8f9]',
                8192: 'bg-[#9ca3af]', 16384: 'bg-[#f472b6]', 32768: 'bg-[#5eead4]', 65536: 'bg-[#fbbf24]',
                131072: 'bg-[#ef4444]', 262144: 'bg-[#8b5cf6]', 524288: 'bg-[#22d3ee]', 1048576: 'bg-[#6b7280]'
            };
            
            const TILE_TEXT_SHADOWS = {
                2: 'rgba(22,101,52,0.5)', 4: 'rgba(180,83,9,0.5)', 8: 'rgba(159,18,57,0.5)', 16: 'rgba(91,33,182,0.5)',
                32: 'rgba(8,126,164,0.5)', 64: 'rgba(55,65,81,0.5)', 128: 'rgba(157,23,77,0.5)', 256: 'rgba(4,120,87,0.5)',
                512: 'rgba(217,119,6,0.5)', 1024: 'rgba(185,28,28,0.5)', 2048: 'rgba(109,40,217,0.5)', 4096: 'rgba(6,182,212,0.5)',
                8192: 'rgba(75,85,99,0.5)', 16384: 'rgba(190,24,93,0.5)', 32768: 'rgba(13,148,136,0.5)', 65536: 'rgba(217,119,6,0.5)',
                131072: 'rgba(220,38,38,0.5)', 262144: 'rgba(124,58,237,0.5)', 524288: 'rgba(14,165,233,0.5)', 1048576: 'rgba(55,65,81,0.5)'
            };

            // --- Game Initialization ---
            async function init() {
                vkBridge.send('VKWebAppInit');
                vkBridge.subscribe(handleVKBridgeEvent);
                try {
                    vkUserId = (await vkBridge.send('VKWebAppGetUserInfo')).id;
                } catch (e) { vkUserId = 'test_user'; }

                await loadData();
                setupAudio();
                applySettings();
                addEventListeners();
                renderOtherGames();
                renderMainMenuButtons();
                showScreen('mainMenu');
            }
            
            function handleVKBridgeEvent(e) {
                const { type, data } = e.detail;
                if (type === 'VKWebAppViewHide' && !bgMusic.paused) { wasMusicPlaying = true; bgMusic.pause(); }
                if (type === 'VKWebAppViewRestore' && wasMusicPlaying && appData.musicEnabled) { bgMusic.play().catch(()=>{}); }
                if (type === 'VKWebAppUpdateConfig') updateGameHeight(data.safe_area_insets);
                if (type === 'VKWebAppShowRewardAdResult' && data.result) {
                    if (boosterState.rewardCallback) boosterState.rewardCallback();
                }
            }

            function setupAudio() {
                mergeSynth = new Tone.PolySynth(Tone.AMSynth, { harmonicity: 1.5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, modulationEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                clickSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            }
            
            async function initAudio() {
                if (audioContextStarted) return;
                try {
                    await Tone.start(); audioContextStarted = true;
                    if (appData.musicEnabled) bgMusic.play().catch(e => {});
                } catch(e) {}
            }

            function startGame(mode) {
                appData.savedGame = {
                    grid: Array(ROWS).fill(null).map(() => Array(COLS).fill(0)),
                    score: 0, gameMode: mode,
                    boosters: { erase: 3, swap: 3 },
                    classicThresholdsReached: []
                };
                isGameOver = false;

                const initialValues = [2, 4, 8];
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                    appData.savedGame.grid[r][c] = initialValues[Math.floor(Math.random() * initialValues.length)];
                }
                while (!isAnyMovePossible(appData.savedGame.grid)) {
                     for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                        appData.savedGame.grid[r][c] = initialValues[Math.floor(Math.random() * initialValues.length)];
                    }
                }
                
                loadGameState();
                showScreen('game');
                renderGrid(true);
                setTimeout(resizeCanvas, 100);
            }

            function resumeSavedGame() {
                if (!appData.savedGame) return;
                loadGameState();
                showScreen('game');
                renderGrid(true);
                setTimeout(resizeCanvas, 100);
            }

            function loadGameState() {
                grid = appData.savedGame.grid;
                currentScore = appData.savedGame.score;
                updateScore(currentScore);
                updateBoosterUI();
            }

            function showScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.add('hidden'));
                screens[screenName].classList.remove('hidden');
                vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).then(() => {
                    vkBridge.send('VKWebAppGetClientConfig').then(c => c.safe_area_insets && updateGameHeight(c.safe_area_insets));
                }).catch(e => {});
            }
            
            function updateGameHeight(safeArea) {
                gameWrapper.style.height = (safeArea && safeArea.bottom > 0) ? `calc(100% - ${safeArea.bottom}px)` : '100%';
                setTimeout(resizeCanvas, 350);
            }

            // --- UI & Rendering ---
            function renderMainMenuButtons() {
                menuButtonsContainer.innerHTML = '';
                if (appData.savedGame) {
                    menuButtonsContainer.innerHTML = `
                        <button id="continue-btn" class="btn btn-continue w-full max-w-xs text-2xl py-4">Продолжить</button>
                        <button id="new-game-btn" class="btn btn-primary w-full max-w-xs text-xl py-3">Новая игра</button>
                        <button id="other-games-btn" class="btn btn-secondary w-full max-w-xs text-xl py-3">Другие игры</button>`;
                    document.getElementById('continue-btn').onclick = () => { initAudio(); resumeSavedGame(); };
                    document.getElementById('new-game-btn').onclick = () => newGameConfirmModal.classList.add('active');
                } else {
                    menuButtonsContainer.innerHTML = `
                        <button class="btn btn-primary w-full max-w-xs text-2xl py-4" data-mode="classic">Классика</button>
                        <button class="btn btn-primary w-full max-w-xs text-xl py-3" data-mode="hard">Хард</button>
                        <button id="other-games-btn" class="btn btn-secondary w-full max-w-xs text-xl py-3">Другие игры</button>`;
                    menuButtonsContainer.querySelectorAll('[data-mode]').forEach(b => b.onclick = () => { initAudio(); startGame(b.dataset.mode); });
                }
                document.getElementById('other-games-btn').onclick = () => { initAudio(); showScreen('otherGames'); };
            }

            function formatTileValue(value) {
                if (value < 1000) return value;
                return (value / 1000).toFixed(value < 10000 ? 1 : 0).replace('.0', '') + 'K';
            }

            function renderGrid(isInitial = false) {
                gameGrid.innerHTML = '';
                for (let i=0; i<ROWS; i++) for (let j=0; j<COLS; j++) {
                    createTile(i, j, grid[i][j], isInitial);
                }
            }

            function createTile(r, c, value, isInitial = false, isNew = false) {
                if (value === 0) return;
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const tile = document.createElement('div');
                tile.id = `tile-${r}-${c}`;
                tile.className = `tile ${TILE_COLORS[value] || 'bg-gray-800'}`;
                tile.textContent = formatTileValue(value);
                tile.style.cssText = `width:${cellWidth}px; height:${cellHeight}px; left:${c*(cellWidth+gap)}px; top:${isNew ? -cellHeight : r*(cellHeight+gap)}px; text-shadow: 1px 1px 3px ${TILE_TEXT_SHADOWS[value] || 'rgba(0,0,0,0.4)'};`;
                if(isInitial) tile.style.transform = 'scale(0)';
                gameGrid.appendChild(tile);
                requestAnimationFrame(() => {
                    tile.style.transition = 'transform 0.2s, top 0.3s, left 0.3s, background-color 0.3s';
                    if (isInitial) tile.style.transform = 'scale(1)';
                    if (isNew) tile.style.top = `${r*(cellHeight+gap)}px`;
                });
            }

            function updateScore(score, isAdding = false) {
                if (isAdding) currentScore += score; else currentScore = score;
                currentScoreEl.textContent = currentScore;
                if (currentScore > appData.stats.highScore) {
                    appData.stats.highScore = currentScore;
                    updateStatsUI();
                }
            }
            
            function resizeCanvas() {
                const gridRect = gameGrid.getBoundingClientRect();
                const containerRect = gameGrid.parentElement.getBoundingClientRect();
                if(gridRect.width === 0) return;
                lineCanvas.width = gridRect.width; lineCanvas.height = gridRect.height;
                lineCanvas.style.top = `${gridRect.top - containerRect.top}px`;
                lineCanvas.style.left = `${gridRect.left - containerRect.left}px`;
            }
            
            function renderOtherGames() {
                const container = document.getElementById('other-games-container'); container.innerHTML = '';
                const games = [{name:'Bubble Shooter',appId:54051411,icon:'https://placehold.co/80x80/60a5fa/ffffff?text=B'},{name:'Тетрис',appId:54051413,icon:'https://placehold.co/80x80/818cf8/ffffff?text=T'},{name:'Tower Blocks',appId:53962513,icon:'https://placehold.co/80x80/c084fc/ffffff?text=TB'},{name:'Блок Про',appId:53936296,icon:'https://placehold.co/80x80/f472b6/ffffff?text=БП'},{name:'Филворды',appId:53867134,icon:'https://placehold.co/80x80/fb7185/ffffff?text=Ф'},{name:'Словли',appId:53861990,icon:'https://placehold.co/80x80/f97316/ffffff?text=С'},{name:'Brick Balls',appId:54023580,icon:'https://placehold.co/80x80/facc15/ffffff?text=BB'},{name:'2048',appId:53965380,icon:'https://placehold.co/80x80/a3e635/ffffff?text=2K'},{name:'Math Matrix',appId:53970659,icon:'https://placehold.co/80x80/4ade80/ffffff?text=M'}];
                games.forEach(g=>{const el=document.createElement('div');el.className="flex flex-col items-center cursor-pointer group";el.dataset.appId=g.appId;el.innerHTML=`<div class="w-20 h-20 bg-gray-200 dark:bg-gray-700 rounded-3xl mb-2 flex items-center justify-center group-hover:scale-105 transition-transform overflow-hidden"><img src="${g.icon}" alt="${g.name}" class="w-full h-full object-cover"></div><span class="text-xs font-medium text-center">${g.name}</span>`;container.appendChild(el);});
            }

            // --- Game Logic ---
            function getGridMetrics() {
                const gap = parseFloat(getComputedStyle(gameGrid).gap);
                const cellWidth = (gameGrid.clientWidth - (gap * (COLS - 1))) / COLS;
                const cellHeight = (gameGrid.clientHeight - (gap * (ROWS - 1))) / ROWS;
                return { cellWidth, cellHeight, gap };
            }
            function getCellFromEvent(e) {
                const rect = gameGrid.getBoundingClientRect(), touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return null;
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const c = Math.floor(x / (cellWidth + gap)), r = Math.floor(y / (cellHeight + gap));
                return (r >= 0 && r < ROWS && c >= 0 && c < COLS) ? {r, c} : null;
            }

            async function handleGridClick(e) {
                if (isMoving || isGameOver || isPaused || isSelecting) return;
                const cell = getCellFromEvent(e);
                if (!cell || grid[cell.r][cell.c] === 0) return;

                if (boosterState.mode === 'erase') {
                    isMoving = true;
                    grid[cell.r][cell.c] = 0;
                    document.getElementById(`tile-${cell.r}-${cell.c}`)?.remove();
                    await applyGravityAndRefillAnimated();
                    finishBooster();
                } else if (boosterState.mode === 'swap') {
                    const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                    if (!boosterState.firstTile) {
                        boosterState.firstTile = { ...cell, el: tileEl };
                        tileEl.classList.add('booster-selected');
                    } else if (boosterState.firstTile.r !== cell.r || boosterState.firstTile.c !== cell.c) {
                        isMoving = true;
                        const first = boosterState.firstTile, second = { ...cell, el: tileEl };
                        
                        [grid[first.r][first.c], grid[second.r][second.c]] = [grid[second.r][second.c], grid[first.r][first.c]];
                        
                        const firstPos = { top: first.el.style.top, left: first.el.style.left };
                        const secondPos = { top: second.el.style.top, left: second.el.style.left };

                        first.el.style.top = secondPos.top; first.el.style.left = secondPos.left;
                        second.el.style.top = firstPos.top; second.el.style.left = firstPos.left;

                        [first.el.id, second.el.id] = [second.el.id, first.el.id];

                        await new Promise(r => setTimeout(r, 300));
                        finishBooster();
                        isMoving = false;
                    }
                }
            }
            
            async function applyGravityAndRefillAnimated() {
                isMoving = true;
                const fallDuration = 300;
                const { cellHeight, gap } = getGridMetrics();
                for (let c = 0; c < COLS; c++) {
                    let writeRow = ROWS - 1;
                    for (let r = ROWS - 1; r >= 0; r--) {
                        if (grid[r][c] !== 0) {
                            if (writeRow !== r) {
                                grid[writeRow][c] = grid[r][c];
                                grid[r][c] = 0;
                                const tileEl = document.getElementById(`tile-${r}-${c}`);
                                if (tileEl) {
                                    tileEl.style.top = `${writeRow * (cellHeight + gap)}px`;
                                    tileEl.id = `tile-${writeRow}-${c}`;
                                }
                            }
                            writeRow--;
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                const initialValues = [2, 4, 8];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === 0) {
                            const value = initialValues[Math.floor(Math.random() * initialValues.length)];
                            grid[r][c] = value;
                            createTile(r, c, value, false, true);
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                isMoving = false;
            }

            function isAnyMovePossible(g) {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (isMovePossibleFrom(r, c, g)) return true;
                    }
                }
                return false;
            }

            function isMovePossibleFrom(r, c, g) {
                const value = g[r][c];
                if (value === 0) return false;
                const q = [{r,c}];
                const visited = new Set([`${r},${c}`]);
                let count = 0;
                while(q.length > 0) {
                    const curr = q.shift();
                    count++;
                    if(count >= 3) return true;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = curr.r + dr;
                            const nc = curr.c + dc;
                            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && g[nr][nc] === value && !visited.has(`${nr},${nc}`)) {
                                visited.add(`${nr},${nc}`);
                                q.push({r: nr, c: nc});
                            }
                        }
                    }
                }
                return false;
            }

            function handleGameOver() {
                isGameOver = true;
                appData.savedGame = null;
                saveData();
                vkBridge.send('VKWebAppShowInterstitialAd').catch(e => {});
                setTimeout(() => {
                    document.getElementById('final-score').textContent = currentScore;
                    document.getElementById('game-over-modal').classList.add('active');
                }, 500);
            }

            // --- Classic Mode Logic ---
            async function checkClassicModeUpgrade(newValue) {
                if (appData.savedGame.gameMode !== 'classic') return;
                const thresholds = [256, 2048, 16384, 131072];
                const triggeredThreshold = thresholds.find(t => newValue >= t && !appData.savedGame.classicThresholdsReached.includes(t));
                if (!triggeredThreshold) return;

                appData.savedGame.classicThresholdsReached.push(triggeredThreshold);
                const power = Math.log2(triggeredThreshold / 256) / 3;
                const v1 = 2 * Math.pow(2, power), v2 = 4 * Math.pow(2, power);

                await upgradeTiles(v1, v1 * 2);
                await upgradeTiles(v2, v2 * 2);
            }

            async function upgradeTiles(fromValue, toValue) {
                const tilesToUpgrade = [];
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                    if (grid[r][c] === fromValue) {
                        grid[r][c] = toValue;
                        tilesToUpgrade.push(document.getElementById(`tile-${r}-${c}`));
                    }
                }
                if (tilesToUpgrade.length > 0) playMergeSound(toValue);
                tilesToUpgrade.forEach(tile => {
                    if (!tile) return;
                    tile.classList.add('tile-upgrade');
                    tile.className = tile.className.replace(/bg-\[\S+\]/, TILE_COLORS[toValue]);
                    tile.textContent = formatTileValue(toValue);
                    tile.style.textShadow = `1px 1px 3px ${TILE_TEXT_SHADOWS[toValue]}`;
                });
                await new Promise(r => setTimeout(r, 400));
                tilesToUpgrade.forEach(tile => tile?.classList.remove('tile-upgrade'));
            }

            // --- Booster Logic ---
            function activateBooster(mode) {
                initAudio();
                const currentBooster = appData.savedGame.boosters[mode];
                if (currentBooster > 0) {
                    appData.savedGame.boosters[mode]--;
                    boosterState.mode = mode;
                    updateBoosterUI();
                } else {
                    boosterState.rewardCallback = () => {
                        appData.savedGame.boosters[mode]++;
                        updateBoosterUI();
                    };
                    vkBridge.send('VKWebAppShowRewardAd', { ad_unit_id: 'your_ad_unit_id' }); // REPLACE ID
                }
            }

            function finishBooster() {
                boosterState = { mode: null, firstTile: null };
                document.querySelectorAll('.booster-selected').forEach(el => el.classList.remove('booster-selected'));
                updateBoosterUI();
            }

            function updateBoosterUI() {
                boosterSwapBtn.classList.toggle('active', boosterState.mode === 'swap');
                boosterEraseBtn.classList.toggle('active', boosterState.mode === 'erase');
                
                ['swap', 'erase'].forEach(mode => {
                    const count = appData.savedGame.boosters[mode];
                    const btn = mode === 'swap' ? boosterSwapBtn : boosterEraseBtn;
                    const countEl = btn.querySelector('.booster-count');
                    btn.classList.toggle('ad', count === 0);
                    countEl.textContent = count > 0 ? count : 'AD';
                });
            }

            // --- Event Handlers & Controls ---
            function addEventListeners() {
                document.getElementById('stats-btn-main').onclick = () => { updateStatsUI(); document.getElementById('stats-modal').classList.add('active'); };
                document.getElementById('rules-btn-main').onclick = () => document.getElementById('rules-modal').classList.add('active');
                document.getElementById('settings-btn-main').onclick = () => document.getElementById('settings-modal').classList.add('active');
                document.getElementById('confirm-new-game-btn').onclick = () => { newGameConfirmModal.classList.remove('active'); modeSelectModal.classList.add('active'); };
                document.getElementById('cancel-new-game-btn').onclick = () => newGameConfirmModal.classList.remove('active');
                modeSelectModal.querySelectorAll('[data-mode]').forEach(b => b.onclick = () => { modeSelectModal.classList.remove('active'); initAudio(); startGame(b.dataset.mode); });
                document.getElementById('cancel-mode-select-btn').onclick = () => modeSelectModal.classList.remove('active');
                document.getElementById('main-menu-btn-pause').onclick = () => {
                    isPaused = false;
                    document.getElementById('pause-modal').classList.remove('active');
                    appData.savedGame.score = currentScore;
                    saveData();
                    renderMainMenuButtons();
                    showScreen('mainMenu');
                };

                boosterSwapBtn.onclick = () => activateBooster('swap');
                boosterEraseBtn.onclick = () => activateBooster('erase');
                gameGrid.addEventListener('click', handleGridClick);

                // --- Existing Listeners ---
                const allButtons = document.querySelectorAll('button');
                allButtons.forEach(btn => btn.addEventListener('click', playClickSound));
                
                document.getElementById('resume-btn').onclick = () => { isPaused = false; document.getElementById('pause-modal').classList.remove('active'); };
                
                [document.getElementById('restart-btn-pause'), document.getElementById('restart-btn-gameover')].forEach(btn => btn.onclick = () => {
                    document.getElementById('pause-modal').classList.remove('active'); document.getElementById('game-over-modal').classList.remove('active');
                    isPaused = false; modeSelectModal.classList.add('active');
                });
                
                document.getElementById('main-menu-btn-gameover').onclick = () => { document.getElementById('game-over-modal').classList.remove('active'); appData.savedGame = null; saveData(); renderMainMenuButtons(); showScreen('mainMenu'); };
                document.getElementById('close-settings-btn').onclick = () => document.getElementById('settings-modal').classList.remove('active');
                document.getElementById('close-rules-btn').onclick = () => document.getElementById('rules-modal').classList.remove('active');
                document.getElementById('close-stats-btn').onclick = () => document.getElementById('stats-modal').classList.remove('active');
                document.getElementById('pause-btn').onclick = () => { if (!isMoving) { isPaused = true; document.getElementById('pause-modal').classList.add('active'); }};
                
                const themeToggle = document.getElementById('theme-toggle');
                themeToggle.onchange = () => { appData.theme = themeToggle.checked ? 'dark' : 'light'; applySettings(); saveData(); };
                
                const musicToggle = document.getElementById('music-toggle');
                musicToggle.onchange = () => { appData.musicEnabled = musicToggle.checked; applySettings(); saveData(); };
                
                const sfxVolumeSlider = document.getElementById('sfx-volume');
                sfxVolumeSlider.oninput = (e) => { appData.sfxVolume = e.target.value; applySettings(); saveData(); };
                
                const gridContainer = document.getElementById('game-grid-container');
                gridContainer.addEventListener('mousedown', handleSelectionStart);
                gridContainer.addEventListener('mousemove', handleSelectionMove);
                document.addEventListener('mouseup', handleSelectionEnd);
                document.addEventListener('mouseleave', handleSelectionEnd);
                gridContainer.addEventListener('touchstart', handleSelectionStart, { passive: false });
                gridContainer.addEventListener('touchmove', handleSelectionMove, { passive: false });
                document.addEventListener('touchend', handleSelectionEnd);
                window.addEventListener('resize', resizeCanvas);
            }
            
            function handleSelectionStart(e) {
                if (isMoving || isGameOver || isPaused || boosterState.mode) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (cell && grid[cell.r][cell.c] > 0) {
                    isSelecting = true;
                    currentSelectionValue = grid[cell.r][cell.c];
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                    updateNextTilePreview();
                }
            }

            function handleSelectionMove(e) {
                if (!isSelecting || selectedPath.length === 0) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (!cell) return;
                const lastCell = selectedPath[selectedPath.length - 1];
                if (cell.r === lastCell.r && cell.c === lastCell.c) return;

                if (selectedPath.length > 1) {
                    const secondLast = selectedPath[selectedPath.length - 2];
                    if (cell.r === secondLast.r && cell.c === secondLast.c) {
                        const removed = selectedPath.pop();
                        document.getElementById(`tile-${removed.r}-${removed.c}`)?.classList.remove('selected');
                        drawLinePath();
                        updateNextTilePreview();
                        return;
                    }
                }

                const alreadySelected = selectedPath.some(p => p.r === cell.r && p.c === cell.c);
                const isAdjacent = Math.abs(cell.r - lastCell.r) <= 1 && Math.abs(cell.c - lastCell.c) <= 1;

                if (!alreadySelected && isAdjacent && grid[cell.r][cell.c] === currentSelectionValue) {
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                    updateNextTilePreview();
                }
            }
            
            async function handleSelectionEnd() {
                if (!isSelecting) return;
                const pathForMerge = [...selectedPath];
                isSelecting = false; ctx.clearRect(0,0,lineCanvas.width, lineCanvas.height);
                selectedPath = []; currentSelectionValue = 0;
                updateNextTilePreview(); clearSelectionUI();
                if (pathForMerge.length >= 3) {
                    isMoving = true;
                    const baseValue = grid[pathForMerge[0].r][pathForMerge[0].c];
                    const power = Math.min(MAX_MERGE_POWER, Math.floor((pathForMerge.length-1)/2));
                    const newValue = baseValue * Math.pow(2, power);
                    playMergeSound(newValue);
                    const mergeTargetCell = pathForMerge[pathForMerge.length-1];
                    const mergeTargetEl = document.getElementById(`tile-${mergeTargetCell.r}-${mergeTargetCell.c}`);
                    if (!mergeTargetEl) { isMoving = false; return; }
                    let mergeScore = 0; const animations = [];
                    const mergeTargetPos = { left: mergeTargetEl.style.left, top: mergeTargetEl.style.top };
                    for (const cell of pathForMerge) {
                        mergeScore += grid[cell.r][cell.c];
                        const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                        if (tileEl && tileEl !== mergeTargetEl) {
                            grid[cell.r][cell.c] = 0;
                            tileEl.style.cssText += `transition: top 0.15s ease-out, left 0.15s ease-out, transform 0.15s ease-out; left: ${mergeTargetPos.left}; top: ${mergeTargetPos.top}; transform: scale(0.5); z-index: 1;`;
                            animations.push(new Promise(r => setTimeout(() => { tileEl?.remove(); r(); }, 150)));
                        }
                    }
                    await Promise.all(animations);
                    grid[mergeTargetCell.r][mergeTargetCell.c] = newValue;
                    mergeTargetEl.className = `tile merged ${TILE_COLORS[newValue] || 'bg-gray-800'}`;
                    mergeTargetEl.textContent = formatTileValue(newValue);
                    mergeTargetEl.style.textShadow = `1px 1px 3px ${TILE_TEXT_SHADOWS[newValue]}`;
                    updateScore(mergeScore, true);
                    if (newValue > appData.stats.maxTile) { appData.stats.maxTile = newValue; updateStatsUI(); }
                    await new Promise(r => setTimeout(r, 300));
                    mergeTargetEl.classList.remove('merged');
                    
                    await checkClassicModeUpgrade(newValue);
                    await applyGravityAndRefillAnimated();
                    
                    appData.savedGame.score = currentScore;
                    saveData();
                    if (!isAnyMovePossible(grid)) handleGameOver();
                }
            }

            function clearSelectionUI() { document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected')); }
            
            function getTileCenter(r, c) {
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const x = c * (cellWidth + gap) + cellWidth / 2;
                const y = r * (cellHeight + gap) + cellHeight / 2;
                return { x, y };
            }

            function drawLinePath() {
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                if (selectedPath.length < 2) return;
                ctx.beginPath();
                const startPoint = getTileCenter(selectedPath[0].r, selectedPath[0].c);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < selectedPath.length; i++) {
                    const point = getTileCenter(selectedPath[i].r, selectedPath[i].c);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }

            function updateNextTilePreview() {
                if (selectedPath.length < 3) {
                    nextTilePreviewEl.textContent = '';
                    nextTilePreviewEl.className = 'w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors';
                    nextTilePreviewEl.style.backgroundColor = 'var(--cell-bg)';
                    return;
                }
                const power = Math.min(MAX_MERGE_POWER, Math.floor((selectedPath.length - 1) / 2));
                const newValue = currentSelectionValue * Math.pow(2, power);
                
                nextTilePreviewEl.textContent = formatTileValue(newValue);
                const colorClass = TILE_COLORS[newValue] || 'bg-gray-800';
                nextTilePreviewEl.className = `w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors ${colorClass}`;
                nextTilePreviewEl.style.backgroundColor = '';
            }

            // --- Sounds ---
            function playMergeSound(value) { if(!audioContextStarted)return;const n=110,t=n*Math.pow(2,Math.log2(value/2)/12+1);mergeSynth.triggerAttackRelease(t,"8n"); }
            function playClickSound() { if(!audioContextStarted)return;clickSynth.triggerAttackRelease("C5","16n"); }

            // --- Settings & Persistence ---
            function applySettings() {
                document.documentElement.classList.toggle('dark', appData.theme === 'dark');
                document.getElementById('theme-toggle').checked = appData.theme === 'dark';
                document.getElementById('music-toggle').checked = appData.musicEnabled;
                if(appData.musicEnabled && audioContextStarted) bgMusic.play().catch(()=>{}); else bgMusic.pause();
                bgMusic.volume = 0.3;
                document.getElementById('sfx-volume').value = appData.sfxVolume;
                Tone.Destination.volume.value = appData.sfxVolume > 0 ? Tone.gainToDb(appData.sfxVolume / 100 * 0.7) : -Infinity;
            }
            async function saveData() { if (!vkUserId) return; const key = `mergemaster_data_${vkUserId}`; try { await vkBridge.send('VKWebAppStorageSet', { key, value: JSON.stringify(appData) }); } catch (e) { localStorage.setItem(key, JSON.stringify(appData)); } }
            async function loadData() { if (!vkUserId) return; const key = `mergemaster_data_${vkUserId}`; let d=null; try { const r = await vkBridge.send('VKWebAppStorageGet', { keys: [key] }); if (r.keys[0]?.value) d=JSON.parse(r.keys[0].value); } catch(e){const l=localStorage.getItem(key);if(l)d=JSON.parse(l);} if(d){appData={...appData,...d};appData.stats={...{highScore:0,maxTile:0},...d.stats};if(!d.theme)appData.theme='dark';} updateStatsUI();}
            function updateStatsUI() { highScoreEl.textContent = formatTileValue(appData.stats.highScore); document.getElementById('stats-max-tile').textContent = formatTileValue(appData.stats.maxTile); }

            init();
        });
    </script>
</body>
</html>

