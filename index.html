<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Triple Merge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #F3F4F6;
            --bg-dark: #111827;
            --card-bg-light: #FFFFFF;
            --card-bg-dark: #1F2937;
            --text-light: #111827;
            --text-dark: #F9FAFB;
            --text-secondary-light: #4B5563;
            --text-secondary-dark: #9CA3AF;
            --accent-color: #3B82F6; /* Blue-500 */
            --accent-hover: #2563EB; /* Blue-600 */
            --grid-bg-light: #D1D5DB; /* Gray-300 */
            --grid-bg-dark: #374151; /* Gray-700 */
            --cell-bg-light: #E5E7EB; /* Gray-200 */
            --cell-bg-dark: #4B5563; /* Gray-600 */
        }
        
        .dark {
            --bg-main: var(--bg-dark);
            --card-bg: var(--card-bg-dark);
            --text-main: var(--text-dark);
            --text-secondary: var(--text-secondary-dark);
            --grid-bg: var(--grid-bg-dark);
            --cell-bg: var(--cell-bg-dark);
        }

        html:not(.dark) {
            --bg-main: var(--bg-light);
            --card-bg: var(--card-bg-light);
            --text-main: var(--text-light);
            --text-secondary: var(--text-secondary-light);
            --grid-bg: var(--grid-bg-light);
            --cell-bg: var(--cell-bg-light);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .game-wrapper {
            width: 100%;
            max-width: 420px;
            height: 100%;
            max-height: 840px;
            background-color: var(--card-bg);
            border-radius: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }
        
        .screen {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 50;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            width: 90%;
            max-width: 380px;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .btn {
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            transition: all 0.2s ease;
            transform: scale(1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
        }
        
        .btn-secondary {
            background-color: var(--cell-bg);
            color: var(--text-main);
        }
        .btn-secondary:hover {
            opacity: 0.9;
        }
        
        .icon-btn {
            background-color: var(--cell-bg);
            color: var(--text-secondary);
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            color: var(--text-main);
            background-color: var(--grid-bg);
        }

        #game-grid-container {
            position: relative;
        }

        #game-grid {
            position: relative;
            background-color: var(--grid-bg);
            padding: 0.75rem;
            border-radius: 1rem;
            touch-action: none; /* Disable panning and zooming on the grid */
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0.75rem;
        }
        
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 800;
            font-size: clamp(1rem, 4.5vw, 1.75rem);
            border-radius: 0.5rem;
            color: white;
            transition: transform 0.2s ease-in-out, top 0.3s ease-in-out, left 0.3s ease-in-out;
            transform: scale(1);
            z-index: 5;
            will-change: transform, top, left;
        }
        
        .tile.selected {
            transform: scale(0.9);
            filter: brightness(1.2);
            border: 3px solid white;
        }
        
        .tile.merged {
            animation: merge-pop 0.3s ease-out forwards;
        }

        @keyframes merge-pop {
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        /* Toggle Switch */
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
        }

        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: var(--cell-bg);
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: var(--accent-color);
        }

        input:focus + .slider {
          box-shadow: 0 0 1px var(--accent-color);
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }

        .rule-item {
            display: flex;
            align-items: center;
            text-align: left;
            padding: 0.75rem;
            background-color: var(--cell-bg);
            border-radius: 0.75rem;
        }
        .rule-item svg {
            flex-shrink: 0;
            margin-right: 0.75rem;
            color: var(--accent-color);
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="game-wrapper">

            <!-- Main Menu Screen -->
            <div id="main-menu" class="screen p-8 flex flex-col justify-between items-center text-center">
                <div></div> <!-- Spacer -->
                <div class="w-full">
                    <h1 class="text-6xl font-black tracking-tighter" style="background: linear-gradient(45deg, var(--accent-color), #f87171); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Triple Merge</h1>
                    <p class="text-lg mt-2" style="color: var(--text-secondary)">Соединяй числа, ставь рекорды</p>
                    <button id="play-btn" class="btn btn-primary w-full max-w-xs mt-16 text-2xl py-4">Играть</button>
                </div>
                <div class="flex space-x-4">
                    <button id="stats-btn-main" class="icon-btn" aria-label="Статистика">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg>
                    </button>
                    <button id="rules-btn-main" class="icon-btn" aria-label="Правила">
                         <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
                    </button>
                    <button id="settings-btn-main" class="icon-btn" aria-label="Настройки">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                    </button>
                </div>
            </div>

            <!-- Game Screen -->
            <div id="game-screen" class="screen p-4 flex-col hidden">
                <div class="flex justify-between items-center p-4">
                    <div class="text-center bg-[var(--cell-bg)] p-2 px-4 rounded-xl w-1/3">
                        <div class="text-xs font-bold uppercase" style="color: var(--text-secondary)">Счет</div>
                        <div id="current-score" class="text-2xl font-bold">0</div>
                    </div>
                     <button id="pause-btn" class="icon-btn" aria-label="Пауза">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                    </button>
                    <div class="text-center bg-[var(--cell-bg)] p-2 px-4 rounded-xl w-1/3">
                        <div class="text-xs font-bold uppercase" style="color: var(--text-secondary)">Рекорд</div>
                        <div id="high-score" class="text-2xl font-bold">0</div>
                    </div>
                </div>
                <div id="game-grid-container" class="w-full flex-grow p-1 flex items-center justify-center">
                    <div id="game-grid" class="w-full" style="aspect-ratio: 5 / 6;">
                        <!-- Tiles will be appended here by JS -->
                    </div>
                    <canvas id="line-canvas" class="absolute pointer-events-none z-10"></canvas>
                </div>
            </div>

        </div>
    </div>

    <!-- Modals -->
    <div id="modal-container">
        <!-- Pause Modal -->
        <div id="pause-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Пауза</h2>
                <div class="space-y-4">
                    <button id="resume-btn" class="btn btn-primary w-full text-lg">Продолжить</button>
                    <button id="restart-btn-pause" class="btn btn-secondary w-full text-lg">Начать заново</button>
                    <button id="main-menu-btn-pause" class="btn btn-secondary w-full text-lg">Главное меню</button>
                </div>
            </div>
        </div>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-2">Игра окончена!</h2>
                <p class="mb-4" style="color: var(--text-secondary)">Ваш счет: <span id="final-score" class="font-bold">0</span></p>
                <div class="space-y-4">
                    <button id="restart-btn-gameover" class="btn btn-primary w-full text-lg">Попробовать снова</button>
                    <button id="main-menu-btn-gameover" class="btn btn-secondary w-full text-lg">Главное меню</button>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Настройки</h2>
                <div class="flex justify-between items-center mb-6">
                    <span class="text-lg">Темная тема</span>
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <button id="close-settings-btn" class="btn btn-secondary w-full text-lg">Закрыть</button>
            </div>
        </div>
        
        <!-- Rules Modal -->
        <div id="rules-modal" class="modal-overlay">
            <div class="modal-content text-left">
                <h2 class="text-3xl font-bold mb-6 text-center">Правила игры</h2>
                <div class="space-y-3">
                    <div class="rule-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 10.5c-1.5 1.5-2 3.5-2 5.5s.5 4 2 5.5c1.5 1.5 3.5 2 5.5 2s4-.5 5.5-2c.8-1.1 1.5-2.5 1.5-4M4 10.5v-6c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v2.5"/><path d="m14 7 7 7-7 7"/><path d="M4 10.5 14 21"/></svg>
                        <span>Соединяйте <strong>3+</strong> одинаковых числа по горизонтали, вертикали или диагонали.</span>
                    </div>
                     <div class="rule-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2Z"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>
                        <span>Длинные цепочки дают плитки большего номинала и больше очков.</span>
                    </div>
                     <div class="rule-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22v-6"/><path d="m12 16-4-4"/><path d="m12 16 4-4"/><path d="M12 2v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="M17.66 6.34l-1.41-1.41"/><path d="M22 12h-2"/><path d="M4 12H2"/></svg>
                        <span>Новые плитки падают сверху, заполняя пустые места.</span>
                    </div>
                </div>
                <button id="close-rules-btn" class="btn btn-secondary w-full text-lg mt-6">Понятно</button>
            </div>
        </div>

        <!-- Stats Modal -->
        <div id="stats-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="text-3xl font-bold mb-6">Статистика</h2>
                <div class="space-y-3 text-left">
                    <div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Лучший счет</span><strong id="stats-high-score">0</strong></div>
                    <div class="flex justify-between p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Макс. плитка</span><strong id="stats-max-tile">0</strong></div>
                </div>
                <button id="close-stats-btn" class="btn btn-secondary w-full text-lg mt-6">Закрыть</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game Constants
            const ROWS = 6;
            const COLS = 5;
            
            // DOM Elements
            const gameGrid = document.getElementById('game-grid');
            const lineCanvas = document.getElementById('line-canvas');
            const ctx = lineCanvas.getContext('2d');
            const mainMenu = document.getElementById('main-menu');
            const gameScreen = document.getElementById('game-screen');
            const currentScoreEl = document.getElementById('current-score');
            const highScoreEl = document.getElementById('high-score');
            
            // Modals & Buttons...
            const pauseModal = document.getElementById('pause-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const settingsModal = document.getElementById('settings-modal');
            const rulesModal = document.getElementById('rules-modal');
            const statsModal = document.getElementById('stats-modal');
            const finalScoreEl = document.getElementById('final-score');
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const restartBtnPause = document.getElementById('restart-btn-pause');
            const mainMenuBtnPause = document.getElementById('main-menu-btn-pause');
            const restartBtnGameOver = document.getElementById('restart-btn-gameover');
            const mainMenuBtnGameOver = document.getElementById('main-menu-btn-gameover');
            const settingsBtnMain = document.getElementById('settings-btn-main');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            const rulesBtnMain = document.getElementById('rules-btn-main');
            const closeRulesBtn = document.getElementById('close-rules-btn');
            const statsBtnMain = document.getElementById('stats-btn-main');
            const closeStatsBtn = document.getElementById('close-stats-btn');
            const themeToggle = document.getElementById('theme-toggle');

            // Game State
            let grid = [];
            let currentScore = 0;
            let isPaused = false;
            let isGameOver = false;
            let isMoving = false;
            let isSelecting = false;
            let selectedPath = [];
            let currentSelectionValue = 0;
            
            // Stats
            let stats = { highScore: 0, maxTile: 0 };

            const TILE_COLORS = {
                2: 'bg-blue-400', 4: 'bg-blue-500', 8: 'bg-indigo-500', 16: 'bg-purple-500',
                32: 'bg-pink-500', 64: 'bg-red-500', 128: 'bg-orange-500', 256: 'bg-yellow-500',
                512: 'bg-lime-500', 1024: 'bg-green-500', 2048: 'bg-teal-500', 4096: 'bg-cyan-500',
                8192: 'bg-sky-500'
            };

            // --- Game Initialization ---
            
            function init() {
                let vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);

                loadTheme();
                loadStats();
                updateScore(0);
                addEventListeners();
            }

            function startGame() {
                mainMenu.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                
                grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                updateScore(0);
                isGameOver = false;

                const initialValues = [2, 4, 8];
                const fillGrid = () => {
                    for(let r = 0; r < ROWS; r++) {
                        for(let c = 0; c < COLS; c++) {
                            grid[r][c] = initialValues[Math.floor(Math.random() * initialValues.length)];
                        }
                    }
                };
                
                fillGrid();
                while (!isAnyMovePossible()) {
                    fillGrid();
                }
                
                renderGrid(true);
                setTimeout(resizeCanvas, 100); // Allow grid to render before sizing canvas
                saveStats();
            }

            // --- UI & Rendering ---
            
            function renderGrid(isInitial = false) {
                gameGrid.innerHTML = '';
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        createTile(i, j, grid[i][j], isInitial);
                    }
                }
            }

            function createTile(r, c, value, isInitial = false, isNew = false) {
                if (value === 0) return;

                const tile = document.createElement('div');
                const { cellWidth, cellHeight, gap } = getGridMetrics();

                tile.id = `tile-${r}-${c}`;
                tile.className = `tile ${TILE_COLORS[value] || 'bg-gray-800'}`;
                tile.textContent = value;
                
                tile.style.width = `${cellWidth}px`;
                tile.style.height = `${cellHeight}px`;
                tile.style.left = `${c * (cellWidth + gap)}px`;
                
                if (isNew) {
                    tile.style.top = `-${cellHeight}px`;
                } else {
                    tile.style.top = `${r * (cellHeight + gap)}px`;
                }

                if (isInitial) {
                    tile.style.transform = 'scale(0)';
                }
                
                gameGrid.appendChild(tile);

                requestAnimationFrame(() => {
                    if (isInitial) {
                        tile.style.transition = 'transform 0.2s';
                        tile.style.transform = 'scale(1)';
                    }
                     if (isNew) {
                        tile.style.top = `${r * (cellHeight + gap)}px`;
                    }
                });
            }

            function updateScore(newScore, isAdding = false) {
                if (isAdding) currentScore += newScore;
                else currentScore = newScore;
                
                currentScoreEl.textContent = currentScore;
                if (currentScore > stats.highScore) {
                    stats.highScore = currentScore;
                }
                highScoreEl.textContent = stats.highScore;
            }
            
            function resizeCanvas() {
                const gridRect = gameGrid.getBoundingClientRect();
                const containerRect = gameGrid.parentElement.getBoundingClientRect();
                lineCanvas.width = gridRect.width;
                lineCanvas.height = gridRect.height;
                lineCanvas.style.top = `${gridRect.top - containerRect.top}px`;
                lineCanvas.style.left = `${gridRect.left - containerRect.left}px`;
            }

            // --- Game Logic ---

            function getGridMetrics() {
                const gap = parseFloat(getComputedStyle(gameGrid).gap);
                const cellWidth = (gameGrid.clientWidth - (gap * (COLS - 1))) / COLS;
                const cellHeight = (gameGrid.clientHeight - (gap * (ROWS - 1))) / ROWS;
                return { cellWidth, cellHeight, gap };
            }

            function getCellFromEvent(e) {
                const rect = gameGrid.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return null;
                
                const { cellWidth, cellHeight, gap } = getGridMetrics();

                const c = Math.floor(x / (cellWidth + gap));
                const r = Math.floor(y / (cellHeight + gap));

                return (r >= 0 && r < ROWS && c >= 0 && c < COLS) ? {r, c} : null;
            }
            
            async function applyGravityAndRefillAnimated() {
                isMoving = true;
                const fallDuration = 300;
                const { cellHeight, gap } = getGridMetrics();

                for (let c = 0; c < COLS; c++) {
                    let writeRow = ROWS - 1;
                    for (let r = ROWS - 1; r >= 0; r--) {
                        if (grid[r][c] !== 0) {
                            if (writeRow !== r) {
                                const value = grid[r][c];
                                grid[writeRow][c] = value;
                                grid[r][c] = 0;

                                const tileEl = document.getElementById(`tile-${r}-${c}`);
                                if (tileEl) {
                                    tileEl.style.top = `${writeRow * (cellHeight + gap)}px`;
                                    tileEl.id = `tile-${writeRow}-${c}`;
                                }
                            }
                            writeRow--;
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, fallDuration));

                const initialValues = [2, 4, 8];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === 0) {
                            const value = initialValues[Math.floor(Math.random() * initialValues.length)];
                            grid[r][c] = value;
                            createTile(r, c, value, false, true);
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                isMoving = false;
            }
            
            function isAnyMovePossible() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (isMovePossibleFrom(r, c)) return true;
                    }
                }
                return false;
            }

            function isMovePossibleFrom(r, c) {
                const value = grid[r][c];
                const q = [{r,c}];
                const visited = new Set([`${r},${c}`]);
                let count = 0;
                while(q.length > 0) {
                    const curr = q.shift();
                    count++;
                    if(count >= 3) return true;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = curr.r + dr;
                            const nc = curr.c + dc;
                            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && grid[nr][nc] === value && !visited.has(`${nr},${nc}`)) {
                                visited.add(`${nr},${nc}`);
                                q.push({r: nr, c: nc});
                            }
                        }
                    }
                }
                return false;
            }

            function handleGameOver() {
                isGameOver = true;
                saveStats();
                setTimeout(() => {
                    finalScoreEl.textContent = currentScore;
                    gameOverModal.classList.add('active');
                }, 500);
            }

            // --- Event Handlers & Controls ---

            function addEventListeners() {
                playBtn.addEventListener('click', startGame);
                statsBtnMain.addEventListener('click', () => { updateStatsUI(); statsModal.classList.add('active'); });
                rulesBtnMain.addEventListener('click', () => rulesModal.classList.add('active'));
                settingsBtnMain.addEventListener('click', () => settingsModal.classList.add('active'));

                resumeBtn.addEventListener('click', () => { isPaused = false; pauseModal.classList.remove('active'); });
                [restartBtnPause, restartBtnGameOver].forEach(btn => btn.addEventListener('click', () => {
                    pauseModal.classList.remove('active');
                    gameOverModal.classList.remove('active');
                    isPaused = false;
                    startGame();
                }));
                [mainMenuBtnPause, mainMenuBtnGameOver].forEach(btn => btn.addEventListener('click', () => {
                    pauseModal.classList.remove('active');
                    gameOverModal.classList.remove('active');
                    gameScreen.classList.add('hidden');
                    mainMenu.classList.remove('hidden');
                    isPaused = false;
                }));
                closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('active'));
                closeRulesBtn.addEventListener('click', () => rulesModal.classList.remove('active'));
                closeStatsBtn.addEventListener('click', () => statsModal.classList.remove('active'));

                pauseBtn.addEventListener('click', () => { if (!isMoving) { isPaused = true; pauseModal.classList.add('active'); }});
                themeToggle.addEventListener('change', toggleTheme);
                
                const gridContainer = document.getElementById('game-grid-container');
                gridContainer.addEventListener('mousedown', handleSelectionStart);
                gridContainer.addEventListener('mousemove', handleSelectionMove);
                document.addEventListener('mouseup', handleSelectionEnd);
                document.addEventListener('mouseleave', handleSelectionEnd);
                gridContainer.addEventListener('touchstart', handleSelectionStart, { passive: false });
                gridContainer.addEventListener('touchmove', handleSelectionMove, { passive: false });
                document.addEventListener('touchend', handleSelectionEnd);

                window.addEventListener('resize', () => {
                    let vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    resizeCanvas();
                });
            }

            function handleSelectionStart(e) {
                if (isMoving || isGameOver || isPaused) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (cell && grid[cell.r][cell.c] > 0) {
                    isSelecting = true;
                    currentSelectionValue = grid[cell.r][cell.c];
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                }
            }
            
            function handleSelectionMove(e) {
                if (!isSelecting || selectedPath.length === 0) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (!cell) return;

                const lastCell = selectedPath[selectedPath.length - 1];
                if (cell.r === lastCell.r && cell.c === lastCell.c) return;
                
                const alreadySelected = selectedPath.some(p => p.r === cell.r && p.c === cell.c);

                if (selectedPath.length > 1) {
                    const secondLast = selectedPath[selectedPath.length - 2];
                    if (cell.r === secondLast.r && cell.c === secondLast.c) {
                        const removed = selectedPath.pop();
                        document.getElementById(`tile-${removed.r}-${removed.c}`).classList.remove('selected');
                        drawLinePath();
                        return;
                    }
                }

                const isAdjacent = Math.abs(cell.r - lastCell.r) <= 1 && Math.abs(cell.c - lastCell.c) <= 1;
                if (!alreadySelected && isAdjacent && grid[cell.r][cell.c] === currentSelectionValue) {
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    drawLinePath();
                }
            }

            async function handleSelectionEnd() {
                if (!isSelecting) return;
                isSelecting = false;
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);

                if (selectedPath.length >= 3) {
                    isMoving = true;
                    
                    const power = Math.floor((selectedPath.length - 1) / 2);
                    const newValue = currentSelectionValue * Math.pow(2, power);
                    
                    const mergeTargetCell = selectedPath[selectedPath.length - 1];
                    const mergeTargetEl = document.getElementById(`tile-${mergeTargetCell.r}-${mergeTargetCell.c}`);
                    let mergeScore = 0;

                    const animations = [];
                    for (const cell of selectedPath) {
                        mergeScore += grid[cell.r][cell.c];
                        const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                        
                        if (tileEl && tileEl !== mergeTargetEl) {
                            grid[cell.r][cell.c] = 0;
                            tileEl.style.left = mergeTargetEl.style.left;
                            tileEl.style.top = mergeTargetEl.style.top;
                            
                            animations.push(new Promise(resolve => setTimeout(() => {
                                tileEl.remove();
                                resolve();
                            }, 300)));
                        }
                    }
                    
                    await Promise.all(animations);

                    grid[mergeTargetCell.r][mergeTargetCell.c] = newValue;
                    if(mergeTargetEl) {
                        mergeTargetEl.className = `tile merged ${TILE_COLORS[newValue] || 'bg-gray-800'}`;
                        mergeTargetEl.textContent = newValue;
                        mergeTargetEl.classList.remove('selected');
                    }
                    
                    updateScore(mergeScore, true);
                    if (newValue > stats.maxTile) stats.maxTile = newValue;
                    saveStats();

                    await new Promise(resolve => setTimeout(resolve, 300));
                    if(mergeTargetEl) mergeTargetEl.classList.remove('merged');

                    await applyGravityAndRefillAnimated();
                    
                    if (!isAnyMovePossible()) handleGameOver();
                } else {
                     clearSelectionUI();
                }
                
                selectedPath = [];
                currentSelectionValue = 0;
            }

            function clearSelectionUI() {
                document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            }
            
            function getTileCenter(r, c) {
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const x = c * (cellWidth + gap) + cellWidth / 2;
                const y = r * (cellHeight + gap) + cellHeight / 2;
                return { x, y };
            }

            function drawLinePath() {
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                if (selectedPath.length < 2) return;
                
                ctx.beginPath();
                const startPoint = getTileCenter(selectedPath[0].r, selectedPath[0].c);
                ctx.moveTo(startPoint.x, startPoint.y);

                for (let i = 1; i < selectedPath.length; i++) {
                    const point = getTileCenter(selectedPath[i].r, selectedPath[i].c);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }

            // --- Persistence (Theme & Stats) ---

            function toggleTheme() {
                const html = document.documentElement;
                html.classList.toggle('dark');
                localStorage.setItem('theme', html.classList.contains('dark') ? 'dark' : 'light');
            }

            function loadTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                if (savedTheme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeToggle.checked = true;
                } else {
                    document.documentElement.classList.remove('dark');
                    themeToggle.checked = false;
                }
            }

            function saveStats() { localStorage.setItem('gameStats', JSON.stringify(stats)); }

            function loadStats() {
                const savedStats = localStorage.getItem('gameStats');
                if (savedStats) stats = JSON.parse(savedStats);
            }
            
            function updateStatsUI() {
                document.getElementById('stats-high-score').textContent = stats.highScore;
                document.getElementById('stats-max-tile').textContent = stats.maxTile;
            }

            // --- Start the engine ---
            init();
        });
    </script>
</body>
</html>

