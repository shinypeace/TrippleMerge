<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Мастер слияния</title>
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #faf8ef;
            --bg-dark: #111827;
            --card-bg-light: #faf8ef; /* Changed for better 2048 feel */
            --card-bg-dark: #1F2937;
            --text-light: #111827;
            --text-dark: #F9FAFB;
            --text-secondary-light: #4B5563;
            --text-secondary-dark: #9CA3AF;
            --accent-color: #3B82F6; 
            --accent-hover: #2563EB;
            --continue-color: #10B981; /* Emerald-500 */
            --continue-hover: #059669; /* Emerald-600 */
            --grid-bg-light: #bbada0;
            --grid-bg-dark: #374151;
            --cell-bg-light: #cdc1b4;
            --cell-bg-dark: #4B5563;
        }
        
        .dark {
            --bg-main: var(--bg-dark);
            --card-bg: var(--card-bg-dark);
            --text-main: var(--text-dark);
            --text-secondary: var(--text-secondary-dark);
            --grid-bg: var(--grid-bg-dark);
            --cell-bg: var(--cell-bg-dark);
        }

        html:not(.dark) {
            --bg-main: var(--bg-light);
            --card-bg: var(--card-bg-light);
            --text-main: var(--text-light);
            --text-secondary: var(--text-secondary-light);
            --grid-bg: var(--grid-bg-light);
            --cell-bg: var(--cell-bg-light);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            /* Prevent page scrolling */
            overflow: hidden;
            overscroll-behavior: none;
            /* Disable text selection */
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .game-wrapper {
            width: 100%;
            max-width: 420px;
            height: 100%;
            max-height: 840px;
            background-color: var(--card-bg);
            border-radius: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease, height 0.3s ease, padding-bottom 0.3s ease;
        }
        
        .screen {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .screen.hidden {
            display: none;
        }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 50;
        }

        .modal-overlay.active { opacity: 1; visibility: visible; }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem; border-radius: 1.5rem;
            width: 90%; max-width: 380px; text-align: center;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content { transform: scale(1); }

        .btn {
            border-radius: 0.75rem; padding: 0.75rem 1.5rem;
            font-weight: 600; transition: all 0.2s ease;
            transform: scale(1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .btn:active { transform: scale(0.95); box-shadow: none; }
        .btn-primary { background-color: var(--accent-color); color: white; }
        .btn-primary:hover { background-color: var(--accent-hover); }
        .btn-secondary { background-color: var(--cell-bg); color: var(--text-main); }
        .btn-secondary:hover { opacity: 0.9; }
        .btn-continue { background-color: var(--continue-color); color: white; }
        .btn-continue:hover { background-color: var(--continue-hover); }
        
        .icon-btn {
            background-color: var(--cell-bg); color: var(--text-secondary);
            width: 3.5rem; height: 3.5rem; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s ease;
        }
        .icon-btn:hover { color: var(--text-main); background-color: var(--grid-bg); }

        #game-grid-container {
            position: relative;
        }
        
        #line-canvas {
             z-index: 4; /* Behind tiles */
        }

        #game-grid {
            position: relative; background-color: var(--grid-bg);
            padding: 0.5rem; border-radius: 1rem;
            touch-action: none; display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0.5rem;
        }
        
        .tile {
            position: absolute; display: flex;
            justify-content: center; align-items: center;
            font-weight: 900; font-size: clamp(1.4rem, 5.5vw, 2.2rem);
            border-radius: 0.375rem; color: white;
            transition: transform 0.2s ease, top 0.3s ease, left 0.3s ease, background-color 0.3s ease;
            transform: scale(1); z-index: 5;
            will-change: transform, top, left;
            text-shadow: 0px 0px 4px rgba(0,0,0,0.7);
        }
        
        .tile.selected { transform: scale(0.9); filter: brightness(1.2); border: 3px solid white; }
        .tile.booster-selected { transform: scale(1.1); box-shadow: 0 0 20px 5px var(--accent-color); z-index: 10; }
        
        .tile.merged { animation: merge-pop 0.3s ease-out forwards; }
        @keyframes merge-pop { 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        
        .tile-upgrade { animation: upgrade-pop 0.4s ease-out forwards; }
        @keyframes upgrade-pop { 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--cell-bg); transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        .booster-btn {
            position: relative; background-color: var(--cell-bg);
            color: var(--text-main); border-radius: 50%;
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 0.5rem;
            width: 4.5rem; height: 4.5rem;
            transition: all 0.2s ease;
        }
        .booster-btn.active { background-color: var(--accent-color); color: white; }
        .booster-count {
            position: absolute; top: -5px; right: -5px;
            background-color: var(--accent-color); color: white;
            font-size: 0.75rem; font-weight: bold;
            width: 1.5rem; height: 1.5rem;
            border-radius: 50%; display: flex;
            justify-content: center; align-items: center;
            border: 2px solid var(--card-bg);
        }
        .booster-btn.ad .booster-count { font-size: 0.6rem; }
    </style>
</head>
<body class="overflow-hidden">
    <audio id="bg-music" src="music.mp3" loop></audio>

    <div class="game-container">
        <div class="game-wrapper">

            <!-- Main Menu Screen -->
            <div id="main-menu" class="screen p-8 flex flex-col justify-between items-center text-center">
                <div></div> <!-- Spacer -->
                <div class="w-full">
                    <h1 class="text-6xl font-black tracking-tighter" style="background: linear-gradient(45deg, var(--accent-color), #f87171); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Мастер слияния</h1>
                    <p class="text-lg mt-2" style="color: var(--text-secondary)">Соединяй числа, ставь рекорды</p>
                    <div id="menu-buttons-container" class="mt-12 flex flex-col items-center space-y-4">
                        <!-- Buttons are generated by JS -->
                    </div>
                </div>
                <div class="flex space-x-4">
                    <button id="stats-btn-main" class="icon-btn" aria-label="Статистика"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg></button>
                    <button id="rules-btn-main" class="icon-btn" aria-label="Правила"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg></button>
                    <button id="settings-btn-main" class="icon-btn" aria-label="Настройки"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button>
                </div>
            </div>

            <!-- Game Screen -->
            <div id="game-screen" class="screen p-4 flex-col hidden">
                <div class="flex justify-between items-center p-4">
                    <div class="w-1/3 text-center bg-[var(--cell-bg)] p-2 px-4 rounded-xl">
                        <div class="text-xs font-bold uppercase" style="color: var(--text-secondary)">Счет</div>
                        <div id="current-score" class="text-2xl font-bold flex justify-center items-center">0</div>
                    </div>
                    <button id="pause-btn" class="icon-btn" aria-label="Пауза"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button>
                    <div class="w-1/3 flex justify-center items-center">
                        <div id="next-tile-preview" class="w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors" style="background-color: var(--cell-bg); text-shadow: 0 0 4px rgba(0,0,0,0.7);"></div>
                    </div>
                </div>
                <div id="game-grid-container" class="w-full flex-grow p-1 flex items-center justify-center">
                    <canvas id="line-canvas" class="absolute pointer-events-none"></canvas>
                    <div id="game-grid" class="w-full" style="aspect-ratio: 5 / 6;"></div>
                </div>
                <div id="booster-bar" class="flex justify-center items-center space-x-4 p-4">
                    <button id="booster-swap" class="booster-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3L4 7l4 4"/><path d="M4 7h16"/><path d="M16 21l4-4-4-4"/><path d="M20 17H4"/></svg>
                        <div class="booster-count">3</div>
                    </button>
                    <button id="booster-erase" class="booster-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>
                        <div class="booster-count">3</div>
                    </button>
                </div>
            </div>
            
            <!-- Other Games Screen -->
            <div id="other-games-screen" class="screen hidden p-4 flex flex-col">
                 <h1 class="text-3xl font-bold text-center mb-4">Другие игры</h1>
                 <div id="other-games-container" class="grid grid-cols-3 gap-x-4 gap-y-5 flex-grow overflow-y-auto p-2"></div>
                 <button id="back-to-menu-btn" class="btn btn-secondary w-full text-lg mt-4">Назад</button>
            </div>

        </div>
    </div>

    <!-- Modals -->
    <div id="modal-container">
        <div id="new-game-confirm-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-2">Новая игра</h2><p class="mb-6" style="color: var(--text-secondary)">Текущий прогресс будет потерян. Вы уверены?</p><div class="space-y-4"><button id="confirm-new-game-btn" class="btn btn-primary w-full text-lg">Да, начать новую</button><button id="cancel-new-game-btn" class="btn btn-secondary w-full text-lg">Отмена</button></div></div></div>
        <div id="mode-select-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-6">Выберите режим</h2><div class="space-y-4"><button class="btn btn-primary w-full text-lg" data-mode="classic">Классика</button><button class="btn btn-primary w-full text-lg" data-mode="hard">Хард</button><button id="cancel-mode-select-btn" class="btn btn-secondary w-full text-lg mt-4">Назад</button></div></div></div>
        <div id="pause-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-6">Пауза</h2><div class="space-y-4"><button id="resume-btn" class="btn btn-primary w-full text-lg">Продолжить</button><button id="restart-btn-pause" class="btn btn-secondary w-full text-lg">Начать заново</button><button id="main-menu-btn-pause" class="btn btn-secondary w-full text-lg">Главное меню</button></div></div></div>
        <div id="game-over-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-2">Игра окончена!</h2><p class="mb-4" style="color: var(--text-secondary)">Ваш счет: <span id="final-score" class="font-bold">0</span></p><div class="space-y-4"><button id="restart-btn-gameover" class="btn btn-primary w-full text-lg">Попробовать снова</button><button id="main-menu-btn-gameover" class="btn btn-secondary w-full text-lg">Главное меню</button></div></div></div>
        <div id="settings-modal" class="modal-overlay"><div class="modal-content text-left space-y-4"><h2 class="text-3xl font-bold mb-2 text-center">Настройки</h2><div class="flex justify-between items-center"><span class="text-lg">Темная тема</span><label class="switch"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label></div><div class="flex justify-between items-center"><span class="text-lg">Музыка</span><label class="switch"><input type="checkbox" id="music-toggle"><span class="slider"></span></label></div><div class="flex justify-between items-center"><span class="text-lg">Звуки</span><input type="range" id="sfx-volume" class="w-1/2" min="0" max="100" value="70"></div><button id="close-settings-btn" class="btn btn-secondary w-full text-lg !mt-6">Закрыть</button></div></div>
        
        <div id="rules-modal" class="modal-overlay">
            <div class="modal-content text-left">
                <h2 class="text-3xl font-bold mb-6 text-center">Правила игры</h2>
                <div class="space-y-4">
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300">💡</div>
                        <div><strong class="block">Цель</strong>Соединяйте 3+ плитки с одинаковым числом, чтобы получить плитку большего номинала.</div>
                    </div>
                    <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-300">🌟</div>
                        <div><strong class="block">Режим "Классика"</strong>При создании больших плиток (256, 2К и т.д.) самые маленькие числа на поле будут улучшаться!</div>
                    </div>
                     <div class="flex items-start gap-4">
                        <div class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-yellow-100 text-yellow-600 dark:bg-yellow-900 dark:text-yellow-300">🔥</div>
                        <div><strong class="block">Бустеры</strong>Используйте <svg xmlns="http://www.w3.org/2000/svg" class="inline h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3L4 7l4 4"/><path d="M4 7h16"/><path d="M16 21l4-4-4-4"/><path d="M20 17H4"/></svg> для замены и <svg xmlns="http://www.w3.org/2000/svg" class="inline h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"/><line x1="18" y1="9" x2="12" y2="15"/><line x1="12" y1="9" x2="18" y2="15"/></svg> для удаления плиток.</div>
                    </div>
                </div>
                <button id="close-rules-btn" class="btn btn-secondary w-full text-lg mt-8">Понятно</button>
            </div>
        </div>

        <div id="stats-modal" class="modal-overlay"><div class="modal-content"><h2 class="text-3xl font-bold mb-6">Статистика</h2><div class="grid grid-cols-2 gap-4 text-left"><div class="col-span-2 text-center text-lg font-semibold border-b pb-2" style="border-color: var(--grid-bg)">Классика</div><div class="p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Рекорд</span><br><strong id="stats-classic-high-score">0</strong></div><div class="p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Макс. плитка</span><br><strong id="stats-classic-max-tile">0</strong></div><div class="col-span-2 text-center text-lg font-semibold border-b pb-2 mt-4" style="border-color: var(--grid-bg)">Хард</div><div class="p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Рекорд</span><br><strong id="stats-hard-high-score">0</strong></div><div class="p-3 rounded-lg" style="background-color: var(--cell-bg)"><span>Макс. плитка</span><br><strong id="stats-hard-max-tile">0</strong></div></div><button id="close-stats-btn" class="btn btn-secondary w-full text-lg mt-6">Закрыть</button></div></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ROWS = 6, COLS = 5, MAX_MERGE_POWER = 6;
            const screens = {
                mainMenu: document.getElementById('main-menu'),
                game: document.getElementById('game-screen'),
                otherGames: document.getElementById('other-games-screen')
            };
            const gameWrapper = document.querySelector('.game-wrapper'),
                  gameGrid = document.getElementById('game-grid'),
                  lineCanvas = document.getElementById('line-canvas'),
                  ctx = lineCanvas.getContext('2d'),
                  currentScoreEl = document.getElementById('current-score'),
                  nextTilePreviewEl = document.getElementById('next-tile-preview'),
                  bgMusic = document.getElementById('bg-music'),
                  menuButtonsContainer = document.getElementById('menu-buttons-container');

            const newGameConfirmModal = document.getElementById('new-game-confirm-modal'),
                  modeSelectModal = document.getElementById('mode-select-modal');
            
            const boosterSwapBtn = document.getElementById('booster-swap'),
                  boosterEraseBtn = document.getElementById('booster-erase');

            let grid = [], currentScore = 0, isPaused = false, isGameOver = false,
                isMoving = false, isSelecting = false, selectedPath = [],
                currentSelectionValue = 0, vkUserId = null, wasMusicPlaying = false,
                audioContextStarted = false, mergeSynth, clickSynth, selectionSynth,
                boosterState = { mode: null, firstTile: null };

            const SELECTION_SCALE = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5'];

            let appData = {
                theme: 'dark', musicEnabled: true, sfxVolume: 70,
                stats: { 
                    classic: { highScore: 0, maxTile: 0 },
                    hard: { highScore: 0, maxTile: 0 } 
                }, 
                savedGame: null
            };

            const TILE_COLORS = {
                2: 'bg-[#6EE7B7]', 4: 'bg-[#FDE047]', 8: 'bg-[#F87171]', 16: 'bg-[#A78BFA]',
                32: 'bg-[#7DD3FC]', 64: 'bg-[#9CA3AF]', 128: 'bg-[#F472B6]', 256: 'bg-[#34D399]',
                512: 'bg-[#FBBF24]', 1024: 'bg-[#EF4444]', 2048: 'bg-[#8B5CF6]', 4096: 'bg-[#38BDF8]',
                8192: 'bg-[#6B7280]', 16384: 'bg-[#EC4899]', 32768: 'bg-[#10B981]', 65536: 'bg-[#F59E0B]',
                131072: 'bg-[#D946EF]', 262144: 'bg-[#6366F1]', 524288: 'bg-[#0EA5E9]', 1048576: 'bg-[#4B5563]'
            };

            // --- Game Initialization ---
            async function init() {
                vkBridge.send('VKWebAppInit');
                vkBridge.subscribe(handleVKBridgeEvent);
                try {
                    vkUserId = (await vkBridge.send('VKWebAppGetUserInfo')).id;
                } catch (e) { vkUserId = 'test_user'; }

                await loadData();
                setupAudio();
                applySettings();
                addEventListeners();
                renderOtherGames();
                renderMainMenuButtons();
                showScreen('mainMenu');
            }
            
            function handleVKBridgeEvent(e) {
                const { type, data } = e.detail;
                if (type === 'VKWebAppViewRestore' || type === 'VKWebAppUpdateConfig') {
                    initAudio(); // Try to start audio when the app becomes visible
                }
                if (type === 'VKWebAppViewHide' && !bgMusic.paused) { 
                    wasMusicPlaying = true; 
                    bgMusic.pause(); 
                }
                if (type === 'VKWebAppViewRestore' && wasMusicPlaying && appData.musicEnabled) {
                     bgMusic.play().catch(()=>{}); 
                }
            }

            function setupAudio() {
                 // Sound for merging tiles - rich and melodic
                mergeSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.2,
                    modulationIndex: 5,
                    envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 0.8 },
                    modulationEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.2, release: 0.8 }
                }).toDestination();
                
                // Sound for UI clicks
                clickSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();

                // Sound for selecting tiles
                selectionSynth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).toDestination();
                selectionSynth.volume.value = -6;
            }
            
            async function initAudio() {
                if (audioContextStarted) return;
                try {
                    await Tone.start(); 
                    audioContextStarted = true;
                    applySettings();
                } catch(e) {
                    // Fallback for browsers that still require a click
                     document.body.addEventListener('click', async () => {
                        if (audioContextStarted) return;
                        await Tone.start();
                        audioContextStarted = true;
                        applySettings();
                    }, { once: true });
                }
            }

            function startGame(mode) {
                appData.savedGame = {
                    grid: Array(ROWS).fill(null).map(() => Array(COLS).fill(0)),
                    score: 0, gameMode: mode,
                    boosters: { erase: 3, swap: 3 },
                    classicThresholdsReached: []
                };
                isGameOver = false;

                const initialValues = getInitialValues();
                const fillGrid = (targetGrid) => {
                    for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                        targetGrid[r][c] = initialValues[Math.floor(Math.random() * initialValues.length)];
                    }
                }
                
                fillGrid(appData.savedGame.grid);
                while (!isAnyMovePossible(appData.savedGame.grid)) {
                     fillGrid(appData.savedGame.grid);
                }
                
                loadGameState();
                showScreen('game');
                renderGrid(true);
                setTimeout(resizeCanvas, 300);
            }

            function resumeSavedGame() {
                if (!appData.savedGame) return;
                loadGameState();
                showScreen('game');
                renderGrid(true);
                setTimeout(resizeCanvas, 300);
            }

            function loadGameState() {
                grid = appData.savedGame.grid;
                currentScore = appData.savedGame.score;
                updateScore(currentScore);
                updateBoosterUI();
            }

            function showScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.add('hidden'));
                screens[screenName].classList.remove('hidden');
                
                vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).then(() => {
                    vkBridge.send('VKWebAppGetClientConfig').then(c => c.safe_area_insets && updateGameHeight(c.safe_area_insets));
                }).catch(e => {});
            }
            
            function updateGameHeight(safeArea) {
                gameWrapper.style.height = (safeArea && safeArea.bottom > 0) ? `calc(100% - ${safeArea.bottom}px)` : '100%';
                setTimeout(resizeCanvas, 350);
            }

            // --- UI & Rendering ---
            function renderMainMenuButtons() {
                menuButtonsContainer.innerHTML = '';
                if (appData.savedGame) {
                    menuButtonsContainer.innerHTML = `
                        <button id="continue-btn" class="btn btn-continue w-full max-w-xs text-2xl py-4">Продолжить</button>
                        <button id="new-game-btn" class="btn btn-primary w-full max-w-xs text-xl py-3">Новая игра</button>
                        <button id="other-games-btn" class="btn btn-secondary w-full max-w-xs text-xl py-3">Другие игры</button>`;
                    document.getElementById('continue-btn').onclick = () => { resumeSavedGame(); };
                    document.getElementById('new-game-btn').onclick = () => { newGameConfirmModal.classList.add('active'); };
                } else {
                    menuButtonsContainer.innerHTML = `
                        <button class="btn btn-primary w-full max-w-xs text-2xl py-4" data-mode="classic">Классика</button>
                        <button class="btn btn-primary w-full max-w-xs text-xl py-3" data-mode="hard">Хард</button>
                        <button id="other-games-btn" class="btn btn-secondary w-full max-w-xs text-xl py-3">Другие игры</button>`;
                    menuButtonsContainer.querySelectorAll('[data-mode]').forEach(b => b.onclick = () => {
                        startGame(b.dataset.mode);
                    });
                }
                document.getElementById('other-games-btn').onclick = () => { showScreen('otherGames'); };
            }

            function formatTileValue(value) {
                if (value < 1000) return value;
                if (value < 1000000) return Math.floor(value / 1000) + 'K';
                return Math.floor(value / 1000000) + 'M';
            }

            function renderGrid(isInitial = false) {
                gameGrid.innerHTML = '';
                for (let i=0; i<ROWS; i++) for (let j=0; j<COLS; j++) {
                    createTile(i, j, grid[i][j], isInitial);
                }
            }

            function createTile(r, c, value, isInitial = false, isNew = false) {
                if (value === 0) return;
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const tile = document.createElement('div');
                tile.id = `tile-${r}-${c}`;
                tile.className = `tile ${TILE_COLORS[value] || TILE_COLORS[value / 1024] || TILE_COLORS[value / (1024*1024)] || 'bg-gray-800'}`;
                tile.textContent = formatTileValue(value);
                tile.style.cssText = `width:${cellWidth}px; height:${cellHeight}px; left:${c*(cellWidth+gap)}px; top:${isNew ? -cellHeight : r*(cellHeight+gap)}px;`;
                if(isInitial) tile.style.transform = 'scale(0)';
                gameGrid.appendChild(tile);
                requestAnimationFrame(() => {
                    tile.style.transition = 'transform 0.2s, top 0.3s, left 0.3s, background-color 0.3s';
                    if (isInitial) tile.style.transform = 'scale(1)';
                    if (isNew) tile.style.top = `${r*(cellHeight+gap)}px`;
                });
            }

            function updateScore(score, isAdding = false) {
                if (isAdding) currentScore += score; else currentScore = score;
                currentScoreEl.textContent = currentScore;
                if (appData.savedGame) {
                    const mode = appData.savedGame.gameMode;
                    if (currentScore > appData.stats[mode].highScore) {
                        appData.stats[mode].highScore = currentScore;
                        updateStatsUI();
                    }
                }
            }
            
            function resizeCanvas() {
                const gridRect = gameGrid.getBoundingClientRect();
                const containerRect = gameGrid.parentElement.getBoundingClientRect();
                if(gridRect.width === 0) return;
                lineCanvas.width = gridRect.width; 
                lineCanvas.height = gridRect.height;
                lineCanvas.style.top = `${gridRect.top - containerRect.top}px`;
                lineCanvas.style.left = `${gridRect.left - containerRect.left}px`;
            }
            
            function renderOtherGames() {
                const container = document.getElementById('other-games-container'); container.innerHTML = '';
                const games = [
                    { name: 'Bubble Shooter', appId: 54051411, icon: 'icon1.png' }, { name: 'Тетрис', appId: 54051413, icon: 'icon2.png' },
                    { name: 'Tower Blocks', appId: 53962513, icon: 'icon3.png' }, { name: 'Блок Про', appId: 53936296, icon: 'icon4.png' },
                    { name: 'Филворды', appId: 53867134, icon: 'icon5.png' }, { name: 'Словли', appId: 53861990, icon: 'icon6.png' },
                    { name: 'Brick Balls', appId: 54023580, icon: 'icon7.png' }, { name: '2048', appId: 53965380, icon: 'icon8.png' },
                    { name: 'Math Matrix', appId: 53970659, icon: 'icon9.png' }
                ];
                games.forEach(g=>{
                    const el=document.createElement('div');
                    el.className="flex flex-col items-center cursor-pointer group";
                    el.onclick = () => vkBridge.send('VKWebAppOpenApp', { app_id: g.appId });
                    el.innerHTML=`<div class="w-20 h-20 bg-gray-200 dark:bg-gray-700 rounded-3xl mb-2 flex items-center justify-center group-hover:scale-105 transition-transform overflow-hidden"><img src="${g.icon}" alt="${g.name}" class="w-full h-full object-cover"></div><span class="text-xs font-medium text-center">${g.name}</span>`;
                    container.appendChild(el);
                });
            }

            // --- Game Logic ---
            function getGridMetrics() {
                const gap = parseFloat(getComputedStyle(gameGrid).gap);
                const cellWidth = (gameGrid.clientWidth - (gap * (COLS - 1))) / COLS;
                const cellHeight = (gameGrid.clientHeight - (gap * (ROWS - 1))) / ROWS;
                return { cellWidth, cellHeight, gap };
            }

            function getCellFromEvent(e) {
                const rect = gameGrid.getBoundingClientRect(), touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return null;
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const c = Math.floor(x / (cellWidth + gap)), r = Math.floor(y / (cellHeight + gap));
                return (r >= 0 && r < ROWS && c >= 0 && c < COLS) ? {r, c} : null;
            }

            async function handleGridClick(e) {
                if (isMoving || isGameOver || isPaused || isSelecting) return;
                const cell = getCellFromEvent(e);
                if (!cell || grid[cell.r][cell.c] === 0) {
                    if (boosterState.mode === 'swap' && boosterState.firstTile) {
                       boosterState.firstTile.el.classList.remove('booster-selected');
                       boosterState.firstTile = null;
                       boosterState.mode = null;
                       updateBoosterUI();
                    }
                    return;
                };

                if (boosterState.mode === 'erase') {
                    appData.savedGame.boosters.erase--;
                    isMoving = true;
                    grid[cell.r][cell.c] = 0;
                    document.getElementById(`tile-${cell.r}-${cell.c}`)?.remove();
                    await applyGravityAndRefillAnimated();
                    finishBooster();
                } else if (boosterState.mode === 'swap') {
                    const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                    if (!boosterState.firstTile) {
                        boosterState.firstTile = { ...cell, el: tileEl };
                        tileEl.classList.add('booster-selected');
                    } else if (boosterState.firstTile.r !== cell.r || boosterState.firstTile.c !== cell.c) {
                        appData.savedGame.boosters.swap--;
                        isMoving = true;
                        const first = boosterState.firstTile, second = { ...cell, el: tileEl };
                        
                        [grid[first.r][first.c], grid[second.r][second.c]] = [grid[second.r][second.c], grid[first.r][first.c]];
                        
                        const firstPos = { top: first.el.style.top, left: first.el.style.left };
                        const secondPos = { top: second.el.style.top, left: second.el.style.left };

                        first.el.style.top = secondPos.top; first.el.style.left = secondPos.left;
                        second.el.style.top = firstPos.top; second.el.style.left = firstPos.left;

                        [first.el.id, second.el.id] = [second.el.id, first.el.id];

                        await new Promise(r => setTimeout(r, 300));
                        finishBooster();
                        isMoving = false;
                    }
                }
            }
            
            async function applyGravityAndRefillAnimated() {
                isMoving = true;
                const fallDuration = 300;
                const { cellHeight, gap } = getGridMetrics();
                for (let c = 0; c < COLS; c++) {
                    let writeRow = ROWS - 1;
                    for (let r = ROWS - 1; r >= 0; r--) {
                        if (grid[r][c] !== 0) {
                            if (writeRow !== r) {
                                grid[writeRow][c] = grid[r][c];
                                grid[r][c] = 0;
                                const tileEl = document.getElementById(`tile-${r}-${c}`);
                                if (tileEl) {
                                    tileEl.style.top = `${writeRow * (cellHeight + gap)}px`;
                                    tileEl.id = `tile-${writeRow}-${c}`;
                                }
                            }
                            writeRow--;
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                
                const initialValues = getInitialValues();
                
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === 0) {
                            const value = initialValues[Math.floor(Math.random() * initialValues.length)];
                            grid[r][c] = value;
                            createTile(r, c, value, false, true);
                        }
                    }
                }
                await new Promise(resolve => setTimeout(resolve, fallDuration));
                isMoving = false;
            }

            function isAnyMovePossible(g) {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (isMovePossibleFrom(r, c, g)) return true;
                    }
                }
                return false;
            }

            function isMovePossibleFrom(r, c, g) {
                const value = g[r][c];
                if (value === 0) return false;
                const q = [{r,c}];
                const visited = new Set([`${r},${c}`]);
                let count = 0;
                while(q.length > 0) {
                    const curr = q.shift();
                    count++;
                    if(count >= 3) return true;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = curr.r + dr;
                            const nc = curr.c + dc;
                            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && g[nr][nc] === value && !visited.has(`${nr},${nc}`)) {
                                visited.add(`${nr},${nc}`);
                                q.push({r: nr, c: nc});
                            }
                        }
                    }
                }
                return false;
            }

            function handleGameOver() {
                isGameOver = true;
                appData.savedGame = null;
                saveData();
                vkBridge.send('VKWebAppShowInterstitialAd').catch(e => {});
                setTimeout(() => {
                    document.getElementById('final-score').textContent = currentScore;
                    document.getElementById('game-over-modal').classList.add('active');
                }, 500);
            }

            // --- Classic Mode Logic ---
            function getInitialValues() {
                if (!appData.savedGame || appData.savedGame.gameMode !== 'classic' || appData.savedGame.classicThresholdsReached.length === 0) {
                    return [2, 4, 8];
                }
                const level = appData.savedGame.classicThresholdsReached.length;
                const base = Math.pow(2, level);
                return [2 * base, 4 * base, 8 * base];
            }

            async function checkClassicModeUpgrade(newValue) {
                if (!appData.savedGame || appData.savedGame.gameMode !== 'classic') return;
                const thresholds = [256, 2048, 16384, 131072];
                const triggeredThreshold = thresholds.find(t => newValue >= t && !appData.savedGame.classicThresholdsReached.includes(t));
                if (!triggeredThreshold) return;

                appData.savedGame.classicThresholdsReached.push(triggeredThreshold);
                const power = appData.savedGame.classicThresholdsReached.length;
                
                const v1_from = 2 * Math.pow(2, power - 1);
                const v1_to = v1_from * 2;
                const v2_from = 4 * Math.pow(2, power - 1);
                const v2_to = v2_from * 2;

                const changes = [];
                // First, find all tiles to upgrade based on the grid's current state.
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] === v1_from) {
                            changes.push({ r, c, toValue: v1_to });
                        } else if (grid[r][c] === v2_from) {
                            changes.push({ r, c, toValue: v2_to });
                        }
                    }
                }
                
                if (changes.length > 0) {
                    await applyUpgrades(changes);
                }
            }

            async function applyUpgrades(changes) {
                const tilesToAnimate = [];
                let maxToValue = 0;
                
                for (const change of changes) {
                    const { r, c, toValue } = change;
                    grid[r][c] = toValue;
                    const tileEl = document.getElementById(`tile-${r}-${c}`);
                    if (tileEl) {
                        tilesToAnimate.push({ el: tileEl, toValue });
                    }
                    if (toValue > maxToValue) maxToValue = toValue;
                }

                if (tilesToAnimate.length > 0) playMergeSound(maxToValue);

                tilesToAnimate.forEach(({ el, toValue }) => {
                    el.classList.add('tile-upgrade');
                    el.className = `tile tile-upgrade ${TILE_COLORS[toValue] || 'bg-gray-800'}`;
                    el.textContent = formatTileValue(toValue);
                });

                await new Promise(r => setTimeout(r, 400));
                
                tilesToAnimate.forEach(({ el }) => el?.classList.remove('tile-upgrade'));
            }


            // --- Booster Logic ---
            async function activateBooster(mode) {
                if (boosterState.mode === mode) {
                    finishBooster();
                    return;
                }

                const currentBoosterCount = appData.savedGame.boosters[mode];
                if (currentBoosterCount > 0) {
                    boosterState.mode = mode;
                    if (boosterState.firstTile) {
                        boosterState.firstTile.el.classList.remove('booster-selected');
                        boosterState.firstTile = null;
                    }
                    updateBoosterUI();
                } else {
                    try {
                        const adData = await vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'reward' });
                        if (adData.result === true) {
                            appData.savedGame.boosters[mode]++;
                            saveData();
                            updateBoosterUI();
                        }
                    } catch (e) {
                        console.error("VK Reward Ad error", e);
                    }
                }
            }

            function finishBooster() {
                if(boosterState.firstTile) boosterState.firstTile.el.classList.remove('booster-selected');
                boosterState = { mode: null, firstTile: null };
                updateBoosterUI();
            }

            function updateBoosterUI() {
                boosterSwapBtn.classList.toggle('active', boosterState.mode === 'swap');
                boosterEraseBtn.classList.toggle('active', boosterState.mode === 'erase');
                
                ['swap', 'erase'].forEach(mode => {
                    if(!appData.savedGame) return;
                    const count = appData.savedGame.boosters[mode];
                    const btn = mode === 'swap' ? boosterSwapBtn : boosterEraseBtn;
                    const countEl = btn.querySelector('.booster-count');
                    btn.classList.toggle('ad', count === 0);
                    countEl.textContent = count > 0 ? count : 'AD';
                });
            }

            // --- Event Handlers & Controls ---
            function addEventListeners() {
                window.addEventListener('contextmenu', e => e.preventDefault());
                document.getElementById('stats-btn-main').onclick = () => { updateStatsUI(); document.getElementById('stats-modal').classList.add('active'); };
                document.getElementById('rules-btn-main').onclick = () => { document.getElementById('rules-modal').classList.add('active'); };
                document.getElementById('settings-btn-main').onclick = () => { document.getElementById('settings-modal').classList.add('active'); };
                
                document.getElementById('confirm-new-game-btn').onclick = () => { newGameConfirmModal.classList.remove('active'); modeSelectModal.classList.add('active'); };
                document.getElementById('cancel-new-game-btn').onclick = () => newGameConfirmModal.classList.remove('active');
                
                modeSelectModal.querySelectorAll('[data-mode]').forEach(b => b.onclick = () => {
                    modeSelectModal.classList.remove('active');
                    startGame(b.dataset.mode);
                });
                document.getElementById('cancel-mode-select-btn').onclick = () => modeSelectModal.classList.remove('active');
                
                document.getElementById('main-menu-btn-pause').onclick = () => {
                    isPaused = false;
                    document.getElementById('pause-modal').classList.remove('active');
                    finishBooster();
                    appData.savedGame.score = currentScore;
                    saveData();
                    renderMainMenuButtons();
                    showScreen('mainMenu');
                };

                boosterSwapBtn.onclick = () => activateBooster('swap');
                boosterEraseBtn.onclick = () => activateBooster('erase');
                gameGrid.addEventListener('click', handleGridClick);

                const allButtons = document.querySelectorAll('button');
                allButtons.forEach(btn => btn.addEventListener('click', playClickSound));
                
                document.getElementById('back-to-menu-btn').onclick = () => showScreen('mainMenu');
                document.getElementById('resume-btn').onclick = () => { isPaused = false; document.getElementById('pause-modal').classList.remove('active'); };
                
                [document.getElementById('restart-btn-pause'), document.getElementById('restart-btn-gameover')].forEach(btn => btn.onclick = () => {
                    document.getElementById('pause-modal').classList.remove('active'); document.getElementById('game-over-modal').classList.remove('active');
                    isPaused = false;
                    finishBooster();
                    modeSelectModal.classList.add('active');
                });
                
                document.getElementById('main-menu-btn-gameover').onclick = () => {
                    document.getElementById('game-over-modal').classList.remove('active');
                    finishBooster();
                    appData.savedGame = null;
                    saveData();
                    renderMainMenuButtons();
                    showScreen('mainMenu');
                };

                document.getElementById('close-settings-btn').onclick = () => document.getElementById('settings-modal').classList.remove('active');
                document.getElementById('close-rules-btn').onclick = () => document.getElementById('rules-modal').classList.remove('active');
                document.getElementById('close-stats-btn').onclick = () => document.getElementById('stats-modal').classList.remove('active');
                document.getElementById('pause-btn').onclick = () => { if (!isMoving) { isPaused = true; document.getElementById('pause-modal').classList.add('active'); }};
                
                const themeToggle = document.getElementById('theme-toggle');
                themeToggle.onchange = () => { appData.theme = themeToggle.checked ? 'dark' : 'light'; applySettings(); saveData(); };
                
                const musicToggle = document.getElementById('music-toggle');
                musicToggle.onchange = () => { appData.musicEnabled = musicToggle.checked; applySettings(); saveData(); };
                
                const sfxVolumeSlider = document.getElementById('sfx-volume');
                sfxVolumeSlider.oninput = (e) => { appData.sfxVolume = e.target.value; applySettings(); saveData(); };
                
                const gridContainer = document.getElementById('game-grid-container');
                gridContainer.addEventListener('mousedown', handleSelectionStart);
                gridContainer.addEventListener('mousemove', handleSelectionMove);
                document.addEventListener('mouseup', handleSelectionEnd);
                document.addEventListener('mouseleave', handleSelectionEnd);
                gridContainer.addEventListener('touchstart', handleSelectionStart, { passive: false });
                gridContainer.addEventListener('touchmove', handleSelectionMove, { passive: false });
                document.addEventListener('touchend', handleSelectionEnd);
                window.addEventListener('resize', resizeCanvas);
            }
            
            function handleSelectionStart(e) {
                if (isMoving || isGameOver || isPaused || boosterState.mode) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (cell && grid[cell.r][cell.c] > 0) {
                    isSelecting = true;
                    currentSelectionValue = grid[cell.r][cell.c];
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    playSelectionSound();
                    drawLinePath();
                    updateNextTilePreview();
                }
            }

            function handleSelectionMove(e) {
                if (!isSelecting || selectedPath.length === 0) return;
                e.preventDefault();
                const cell = getCellFromEvent(e);
                if (!cell) return;
                const lastCell = selectedPath[selectedPath.length - 1];
                if (cell.r === lastCell.r && cell.c === lastCell.c) return;

                if (selectedPath.length > 1) {
                    const secondLast = selectedPath[selectedPath.length - 2];
                    if (cell.r === secondLast.r && cell.c === secondLast.c) {
                        const removed = selectedPath.pop();
                        document.getElementById(`tile-${removed.r}-${removed.c}`)?.classList.remove('selected');
                        playSelectionSound(); // Play sound on deselection
                        drawLinePath();
                        updateNextTilePreview();
                        return;
                    }
                }

                const alreadySelected = selectedPath.some(p => p.r === cell.r && p.c === cell.c);
                const isAdjacent = Math.abs(cell.r - lastCell.r) <= 1 && Math.abs(cell.c - lastCell.c) <= 1;

                if (!alreadySelected && isAdjacent && grid[cell.r][cell.c] === currentSelectionValue) {
                    selectedPath.push(cell);
                    document.getElementById(`tile-${cell.r}-${cell.c}`).classList.add('selected');
                    playSelectionSound();
                    drawLinePath();
                    updateNextTilePreview();
                }
            }
            
            async function handleSelectionEnd() {
                if (!isSelecting) return;
                const pathForMerge = [...selectedPath];
                isSelecting = false; ctx.clearRect(0,0,lineCanvas.width, lineCanvas.height);
                selectedPath = []; currentSelectionValue = 0;
                updateNextTilePreview(); clearSelectionUI();
                if (pathForMerge.length >= 3) {
                    isMoving = true;
                    const baseValue = grid[pathForMerge[0].r][pathForMerge[0].c];
                    const power = Math.min(MAX_MERGE_POWER, Math.floor((pathForMerge.length-1)/2));
                    const newValue = baseValue * Math.pow(2, power);
                    playMergeSound(newValue);
                    const mergeTargetCell = pathForMerge[pathForMerge.length-1];
                    const mergeTargetEl = document.getElementById(`tile-${mergeTargetCell.r}-${mergeTargetCell.c}`);
                    if (!mergeTargetEl) { isMoving = false; return; }
                    let mergeScore = 0; const animations = [];
                    const mergeTargetPos = { left: mergeTargetEl.style.left, top: mergeTargetEl.style.top };
                    for (const cell of pathForMerge) {
                        mergeScore += grid[cell.r][cell.c];
                        const tileEl = document.getElementById(`tile-${cell.r}-${cell.c}`);
                        if (tileEl && tileEl !== mergeTargetEl) {
                            grid[cell.r][cell.c] = 0;
                            tileEl.style.cssText += `transition: top 0.15s ease-out, left 0.15s ease-out, transform 0.15s ease-out; left: ${mergeTargetPos.left}; top: ${mergeTargetPos.top}; transform: scale(0.5); z-index: 1;`;
                            animations.push(new Promise(r => setTimeout(() => { tileEl?.remove(); r(); }, 150)));
                        }
                    }
                    await Promise.all(animations);
                    grid[mergeTargetCell.r][mergeTargetCell.c] = newValue;
                    mergeTargetEl.className = `tile merged ${TILE_COLORS[newValue] || TILE_COLORS[newValue / 1024] || TILE_COLORS[newValue / (1024*1024)] || 'bg-gray-800'}`;
                    mergeTargetEl.textContent = formatTileValue(newValue);
                    updateScore(mergeScore, true);
                    if (appData.savedGame) {
                        const mode = appData.savedGame.gameMode;
                        if (newValue > appData.stats[mode].maxTile) { 
                            appData.stats[mode].maxTile = newValue; 
                            updateStatsUI(); 
                        }
                    }
                    await new Promise(r => setTimeout(r, 300));
                    mergeTargetEl.classList.remove('merged');
                    
                    await checkClassicModeUpgrade(newValue);
                    await applyGravityAndRefillAnimated();
                    
                    if (appData.savedGame) appData.savedGame.score = currentScore;
                    saveData();
                    if (!isAnyMovePossible(grid)) handleGameOver();
                }
            }

            function clearSelectionUI() { document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected')); }
            
            function getTileCenter(r, c) {
                const { cellWidth, cellHeight, gap } = getGridMetrics();
                const x = c * (cellWidth + gap) + cellWidth / 2;
                const y = r * (cellHeight + gap) + cellHeight / 2;
                return { x, y };
            }

            function drawLinePath() {
                ctx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
                if (selectedPath.length < 2) return;
                ctx.beginPath();
                const startPoint = getTileCenter(selectedPath[0].r, selectedPath[0].c);
                ctx.moveTo(startPoint.x, startPoint.y);
                for (let i = 1; i < selectedPath.length; i++) {
                    const point = getTileCenter(selectedPath[i].r, selectedPath[i].c);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }

            function updateNextTilePreview() {
                if (selectedPath.length < 3) {
                    nextTilePreviewEl.textContent = '';
                    nextTilePreviewEl.className = 'w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors';
                    nextTilePreviewEl.style.backgroundColor = 'var(--cell-bg)';
                    return;
                }
                const power = Math.min(MAX_MERGE_POWER, Math.floor((selectedPath.length - 1) / 2));
                const newValue = currentSelectionValue * Math.pow(2, power);
                
                nextTilePreviewEl.textContent = formatTileValue(newValue);
                const colorClass = TILE_COLORS[newValue] || TILE_COLORS[newValue / 1024] || TILE_COLORS[newValue / (1024*1024)] || 'bg-gray-800';
                nextTilePreviewEl.className = `w-12 h-12 rounded-lg flex items-center justify-center font-bold text-white text-xl transition-colors ${colorClass}`;
                nextTilePreviewEl.style.backgroundColor = '';
            }

            // --- Sounds ---
            function playSelectionSound() {
                if (!audioContextStarted || selectedPath.length === 0) return;
                const noteIndex = (selectedPath.length - 1) % SELECTION_SCALE.length;
                const note = SELECTION_SCALE[noteIndex];
                selectionSynth.triggerAttackRelease(note, "16n");
            }

            function playMergeSound(value) {
                if (!audioContextStarted) return;
                const notes = ["C4", "E4", "G4", "A4", "C5", "E5", "G5", "A5", "C6", "E6", "G6"];
                const step = Math.floor(Math.log2(value)) - 1; // For 2, step=0; for 4, step=1 etc.
                const note = notes[Math.min(step, notes.length - 1)];

                const chord = [
                    note,
                    Tone.Frequency(note).transpose(4).toFrequency(), // Major third
                    Tone.Frequency(note).transpose(7).toFrequency()  // Perfect fifth
                ];
                
                // Dynamically adjust volume: louder for smaller merges, slightly softer for big ones
                const volume = -12 + Math.min(step, 5) * 1.5; // Starts at -12dB, goes up to -4.5dB
                mergeSynth.volume.value = volume;
                
                mergeSynth.triggerAttackRelease(chord, "8n");
            }
            
            function playClickSound() { if(!audioContextStarted)return;clickSynth.triggerAttackRelease("C5","16n"); }

            // --- Settings & Persistence ---
            function applySettings() {
                document.documentElement.classList.toggle('dark', appData.theme === 'dark');
                document.getElementById('theme-toggle').checked = appData.theme === 'dark';
                document.getElementById('music-toggle').checked = appData.musicEnabled;
                if(appData.musicEnabled && audioContextStarted) {
                     bgMusic.play().catch(()=>{});
                } else {
                     bgMusic.pause();
                }
                bgMusic.volume = 0.3;
                document.getElementById('sfx-volume').value = appData.sfxVolume;
                Tone.Destination.volume.value = appData.sfxVolume > 0 ? Tone.gainToDb(appData.sfxVolume / 100 * 0.7) : -Infinity;
            }
            async function saveData() { if (!vkUserId) return; const key = `mergemaster_data_${vkUserId}`; try { await vkBridge.send('VKWebAppStorageSet', { key, value: JSON.stringify(appData) }); } catch (e) { localStorage.setItem(key, JSON.stringify(appData)); } }
            async function loadData() { 
                if (!vkUserId) return; 
                const key = `mergemaster_data_${vkUserId}`; 
                let d=null; 
                try { 
                    const r = await vkBridge.send('VKWebAppStorageGet', { keys: [key] }); 
                    if (r.keys[0]?.value) d=JSON.parse(r.keys[0].value); 
                } catch(e){
                    const l=localStorage.getItem(key);
                    if(l)d=JSON.parse(l);
                } 
                if(d){
                    appData={...appData,...d};
                    if (!d.stats.classic || !d.stats.hard) { // Migration for old stats structure
                        appData.stats = {
                            classic: { highScore: d.stats.highScore || 0, maxTile: d.stats.maxTile || 0 },
                            hard: { highScore: 0, maxTile: 0 }
                        };
                    } else {
                        appData.stats = d.stats;
                    }
                    if(!d.theme)appData.theme='dark';
                } 
                updateStatsUI();
            }
            function updateStatsUI() { 
                document.getElementById('stats-classic-high-score').textContent = formatTileValue(appData.stats.classic.highScore); 
                document.getElementById('stats-classic-max-tile').textContent = formatTileValue(appData.stats.classic.maxTile);
                document.getElementById('stats-hard-high-score').textContent = formatTileValue(appData.stats.hard.highScore); 
                document.getElementById('stats-hard-max-tile').textContent = formatTileValue(appData.stats.hard.maxTile);
            }

            init();
        });
    </script>
</body>
</html>

